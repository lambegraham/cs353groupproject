'use strict';

var define = require('../');
var test = require('tape');
var keys = require('object-keys');

var arePropertyDescriptorsSupported = function () {
	var obj = { a: 1 ***REMOVED***;
	try {
		Object.defineProperty(obj, 'x', { value: obj ***REMOVED***);
		return obj.x === obj;
	***REMOVED*** catch (e) { /* this is IE 8. */
		return false;
	***REMOVED***
***REMOVED***;
var descriptorsSupported = !!Object.defineProperty && arePropertyDescriptorsSupported();

var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

test('defineProperties', function (dt) {
	dt.test('with descriptor support', { skip: !descriptorsSupported ***REMOVED***, function (t) {
		var getDescriptor = function (value) {
			return {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			***REMOVED***;
		***REMOVED***;

		var obj = {
			a: 1,
			b: 2,
			c: 3
		***REMOVED***;
		t.deepEqual(keys(obj), ['a', 'b', 'c'], 'all literal-set keys start enumerable');
		define(obj, {
			b: 3,
			c: 4,
			d: 5
		***REMOVED***);
		t.deepEqual(obj, {
			a: 1,
			b: 2,
			c: 3
		***REMOVED***, 'existing properties were not overridden');
		t.deepEqual(Object.getOwnPropertyDescriptor(obj, 'd'), getDescriptor(5), 'new property "d" was added and is not enumerable');
		t.deepEqual(['a', 'b', 'c'], keys(obj), 'new keys are not enumerable');

		define(obj, {
			a: 2,
			b: 3,
			c: 4
		***REMOVED***, {
			a: function () { return true; ***REMOVED***,
			b: function () { return false; ***REMOVED***
		***REMOVED***);
		t.deepEqual(obj, {
			b: 2,
			c: 3
		***REMOVED***, 'properties only overriden when predicate exists and returns true');
		t.deepEqual(Object.getOwnPropertyDescriptor(obj, 'd'), getDescriptor(5), 'existing property "d" remained and is not enumerable');
		t.deepEqual(Object.getOwnPropertyDescriptor(obj, 'a'), getDescriptor(2), 'existing property "a" was overridden and is not enumerable');
		t.deepEqual(['b', 'c'], keys(obj), 'overridden keys are not enumerable');

		t.end();
	***REMOVED***);

	dt.test('without descriptor support', { skip: descriptorsSupported ***REMOVED***, function (t) {
		var obj = {
			a: 1,
			b: 2,
			c: 3
		***REMOVED***;
		define(obj, {
			b: 3,
			c: 4,
			d: 5
		***REMOVED***);
		t.deepEqual(obj, {
			a: 1,
			b: 2,
			c: 3,
			d: 5
		***REMOVED***, 'existing properties were not overridden, new properties were added');

		define(obj, {
			a: 2,
			b: 3,
			c: 4
		***REMOVED***, {
			a: function () { return true; ***REMOVED***,
			b: function () { return false; ***REMOVED***
		***REMOVED***);
		t.deepEqual(obj, {
			a: 2,
			b: 2,
			c: 3,
			d: 5
		***REMOVED***, 'properties only overriden when predicate exists and returns true');

		t.end();
	***REMOVED***);

	dt.end();
***REMOVED***);

test('symbols', { skip: !hasSymbols ***REMOVED***, function (t) {
	var sym = Symbol('foo');
	var obj = {***REMOVED***;
	var aValue = {***REMOVED***;
	var bValue = {***REMOVED***;
	var properties = { a: aValue ***REMOVED***;
	properties[sym] = bValue;

	define(obj, properties);

	t.deepEqual(Object.keys(obj), [], 'object has no enumerable keys');
	t.deepEqual(Object.getOwnPropertyNames(obj), ['a'], 'object has non-enumerable "a" key');
	t.deepEqual(Object.getOwnPropertySymbols(obj), [sym], 'object has non-enumerable symbol key');
	t.equal(obj.a, aValue, 'string keyed value is defined');
	t.equal(obj[sym], bValue, 'symbol keyed value is defined');

	t.end();
***REMOVED***);
