"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const call_1 = require("./call");
const channel_1 = require("./channel");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const CHANNEL_SYMBOL = Symbol();
/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
class Client {
    constructor(address, credentials, options = {***REMOVED***) {
        if (options.channelOverride) {
            this[CHANNEL_SYMBOL] = options.channelOverride;
      ***REMOVED***
        else if (options.channelFactoryOverride) {
            this[CHANNEL_SYMBOL] = options.channelFactoryOverride(address, credentials, options);
      ***REMOVED***
        else {
            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
      ***REMOVED***
  ***REMOVED***
    close() {
        this[CHANNEL_SYMBOL].close();
  ***REMOVED***
    getChannel() {
        return this[CHANNEL_SYMBOL];
  ***REMOVED***
    waitForReady(deadline, callback) {
        const checkState = (err) => {
            if (err) {
                callback(new Error('Failed to connect before the deadline'));
                return;
          ***REMOVED***
            let newState;
            try {
                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          ***REMOVED***
            catch (e) {
                callback(new Error('The channel has been closed'));
                return;
          ***REMOVED***
            if (newState === channel_1.ConnectivityState.READY) {
                callback();
          ***REMOVED***
            else {
                try {
                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
              ***REMOVED***
                catch (e) {
                    callback(new Error('The channel has been closed'));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        setImmediate(checkState);
  ***REMOVED***
    handleUnaryResponse(call, deserialize, callback) {
        let responseMessage = null;
        call.on('data', (data) => {
            if (responseMessage != null) {
                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
          ***REMOVED***
            try {
                responseMessage = deserialize(data);
          ***REMOVED***
            catch (e) {
                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');
          ***REMOVED***
      ***REMOVED***);
        call.on('status', (status) => {
            /* We assume that call emits status after it emits end, and that it
             * accounts for any cancelWithStatus calls up until it emits status.
             * Therefore, considering the above event handlers, status.code should be
             * OK if and only if we have a non-null responseMessage */
            if (status.code === constants_1.Status.OK) {
                callback(null, responseMessage);
          ***REMOVED***
            else {
                callback(call_1.callErrorFromStatus(status));
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (arg1 instanceof Function) {
            return { metadata: new metadata_1.Metadata(), options: {***REMOVED***, callback: arg1 ***REMOVED***;
      ***REMOVED***
        else if (arg2 instanceof Function) {
            if (arg1 instanceof metadata_1.Metadata) {
                return { metadata: arg1, options: {***REMOVED***, callback: arg2 ***REMOVED***;
          ***REMOVED***
            else {
                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 ***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        else {
            if (!(arg1 instanceof metadata_1.Metadata &&
                arg2 instanceof Object &&
                arg3 instanceof Function)) {
                throw new Error('Incorrect arguments passed');
          ***REMOVED***
            return { metadata: arg1, options: arg2, callback: arg3 ***REMOVED***;
      ***REMOVED***
  ***REMOVED***
    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        ({ metadata, options, callback ***REMOVED*** = this.checkOptionalUnaryResponseArguments(metadata, options, callback));
        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);
        if (options.credentials) {
            call.setCredentials(options.credentials);
      ***REMOVED***
        const message = serialize(argument);
        const writeObj = { message ***REMOVED***;
        call.sendMetadata(metadata);
        call.write(writeObj);
        call.end();
        this.handleUnaryResponse(call, deserialize, callback);
        return new call_1.ClientUnaryCallImpl(call);
  ***REMOVED***
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        ({ metadata, options, callback ***REMOVED*** = this.checkOptionalUnaryResponseArguments(metadata, options, callback));
        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);
        if (options.credentials) {
            call.setCredentials(options.credentials);
      ***REMOVED***
        call.sendMetadata(metadata);
        this.handleUnaryResponse(call, deserialize, callback);
        return new call_1.ClientWritableStreamImpl(call, serialize);
  ***REMOVED***
    checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
            metadata = arg1;
            if (arg2) {
                options = arg2;
          ***REMOVED***
            else {
                options = {***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        else {
            if (arg1) {
                options = arg1;
          ***REMOVED***
            else {
                options = {***REMOVED***;
          ***REMOVED***
            metadata = new metadata_1.Metadata();
      ***REMOVED***
        return { metadata, options ***REMOVED***;
  ***REMOVED***
    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        ({ metadata, options ***REMOVED*** = this.checkMetadataAndOptions(metadata, options));
        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);
        if (options.credentials) {
            call.setCredentials(options.credentials);
      ***REMOVED***
        const message = serialize(argument);
        const writeObj = { message ***REMOVED***;
        call.sendMetadata(metadata);
        call.write(writeObj);
        call.end();
        return new call_1.ClientReadableStreamImpl(call, deserialize);
  ***REMOVED***
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        ({ metadata, options ***REMOVED*** = this.checkMetadataAndOptions(metadata, options));
        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);
        if (options.credentials) {
            call.setCredentials(options.credentials);
      ***REMOVED***
        call.sendMetadata(metadata);
        return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);
  ***REMOVED***
***REMOVED***
exports.Client = Client;
//# sourceMappingURL=client.js.map