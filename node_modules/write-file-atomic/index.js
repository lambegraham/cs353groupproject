'use strict'
module.exports = writeFile
module.exports.sync = writeFileSync
module.exports._getTmpname = getTmpname // for testing
module.exports._cleanupOnExit = cleanupOnExit

const fs = require('fs')
const MurmurHash3 = require('imurmurhash')
const onExit = require('signal-exit')
const path = require('path')
const isTypedArray = require('is-typedarray')
const typedArrayToBuffer = require('typedarray-to-buffer')
const { promisify ***REMOVED*** = require('util')
const activeFiles = {***REMOVED***

// if we run inside of a worker_thread, `process.pid` is not unique
/* istanbul ignore next */
const threadId = (function getId () {
  try {
    const workerThreads = require('worker_threads')

    /// if we are in main thread, this is set to `0`
    return workerThreads.threadId
***REMOVED*** catch (e) {
    // worker_threads are not available, fallback to 0
    return 0
***REMOVED***
***REMOVED***)()

let invocations = 0
function getTmpname (filename) {
  return filename + '.' +
    MurmurHash3(__filename)
      .hash(String(process.pid))
      .hash(String(threadId))
      .hash(String(++invocations))
      .result()
***REMOVED***

function cleanupOnExit (tmpfile) {
  return () => {
    try {
      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)
  ***REMOVED*** catch (_) {***REMOVED***
***REMOVED***
***REMOVED***

function serializeActiveFile (absoluteName) {
  return new Promise(resolve => {
    // make a queue if it doesn't already exist
    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = []

    activeFiles[absoluteName].push(resolve) // add this job to the queue
    if (activeFiles[absoluteName].length === 1) resolve() // kick off the first one
***REMOVED***)
***REMOVED***

async function writeFileAsync (filename, data, options = {***REMOVED***) {
  if (typeof options === 'string') {
    options = { encoding: options ***REMOVED***
***REMOVED***

  let fd
  let tmpfile
  /* istanbul ignore next -- The closure only gets called when onExit triggers */
  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))
  const absoluteName = path.resolve(filename)

  try {
    await serializeActiveFile(absoluteName)
    const truename = await promisify(fs.realpath)(filename).catch(() => filename)
    tmpfile = getTmpname(truename)

    if (!options.mode || !options.chown) {
      // Either mode or chown is not explicitly set
      // Default behavior is to copy it from original file
      const stats = await promisify(fs.stat)(truename).catch(() => {***REMOVED***)
      if (stats) {
        if (options.mode == null) {
          options.mode = stats.mode
      ***REMOVED***

        if (options.chown == null && process.getuid) {
          options.chown = { uid: stats.uid, gid: stats.gid ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)
    if (options.tmpfileCreated) {
      await options.tmpfileCreated(tmpfile)
  ***REMOVED***
    if (isTypedArray(data)) {
      data = typedArrayToBuffer(data)
  ***REMOVED***
    if (Buffer.isBuffer(data)) {
      await promisify(fs.write)(fd, data, 0, data.length, 0)
  ***REMOVED*** else if (data != null) {
      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))
  ***REMOVED***

    if (options.fsync !== false) {
      await promisify(fs.fsync)(fd)
  ***REMOVED***

    await promisify(fs.close)(fd)
    fd = null

    if (options.chown) {
      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid)
  ***REMOVED***

    if (options.mode) {
      await promisify(fs.chmod)(tmpfile, options.mode)
  ***REMOVED***

    await promisify(fs.rename)(tmpfile, truename)
***REMOVED*** finally {
    if (fd) {
      await promisify(fs.close)(fd).catch(
        /* istanbul ignore next */
        () => {***REMOVED***
      )
  ***REMOVED***
    removeOnExitHandler()
    await promisify(fs.unlink)(tmpfile).catch(() => {***REMOVED***)
    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile
    if (activeFiles[absoluteName].length > 0) {
      activeFiles[absoluteName][0]() // start next job if one is pending
  ***REMOVED*** else delete activeFiles[absoluteName]
***REMOVED***
***REMOVED***

function writeFile (filename, data, options, callback) {
  if (options instanceof Function) {
    callback = options
    options = {***REMOVED***
***REMOVED***

  const promise = writeFileAsync(filename, data, options)
  if (callback) {
    promise.then(callback, callback)
***REMOVED***

  return promise
***REMOVED***

function writeFileSync (filename, data, options) {
  if (typeof options === 'string') options = { encoding: options ***REMOVED***
  else if (!options) options = {***REMOVED***
  try {
    filename = fs.realpathSync(filename)
***REMOVED*** catch (ex) {
    // it's ok, it'll happen on a not yet existing file
***REMOVED***
  const tmpfile = getTmpname(filename)

  if (!options.mode || !options.chown) {
    // Either mode or chown is not explicitly set
    // Default behavior is to copy it from original file
    try {
      const stats = fs.statSync(filename)
      options = Object.assign({***REMOVED***, options)
      if (!options.mode) {
        options.mode = stats.mode
    ***REMOVED***
      if (!options.chown && process.getuid) {
        options.chown = { uid: stats.uid, gid: stats.gid ***REMOVED***
    ***REMOVED***
  ***REMOVED*** catch (ex) {
      // ignore stat errors
  ***REMOVED***
***REMOVED***

  let fd
  const cleanup = cleanupOnExit(tmpfile)
  const removeOnExitHandler = onExit(cleanup)

  let threw = true
  try {
    fd = fs.openSync(tmpfile, 'w', options.mode)
    if (options.tmpfileCreated) {
      options.tmpfileCreated(tmpfile)
  ***REMOVED***
    if (isTypedArray(data)) {
      data = typedArrayToBuffer(data)
  ***REMOVED***
    if (Buffer.isBuffer(data)) {
      fs.writeSync(fd, data, 0, data.length, 0)
  ***REMOVED*** else if (data != null) {
      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))
  ***REMOVED***
    if (options.fsync !== false) {
      fs.fsyncSync(fd)
  ***REMOVED***
    fs.closeSync(fd)
    fd = null
    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)
    if (options.mode) fs.chmodSync(tmpfile, options.mode)
    fs.renameSync(tmpfile, filename)
    threw = false
***REMOVED*** finally {
    if (fd) {
      try {
        fs.closeSync(fd)
    ***REMOVED*** catch (ex) {
        // ignore close errors at this stage, error may have closed fd already.
    ***REMOVED***
  ***REMOVED***
    removeOnExitHandler()
    if (threw) {
      cleanup()
  ***REMOVED***
***REMOVED***
***REMOVED***
