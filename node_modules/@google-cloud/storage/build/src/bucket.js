"use strict";
/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const common_1 = require("@google-cloud/common");
const paginator_1 = require("@google-cloud/paginator");
const promisify_1 = require("@google-cloud/promisify");
const arrify = require("arrify");
const extend = require("extend");
const fs = require("fs");
const mime = require("mime-types");
const path = require("path");
const p_limit_1 = require("p-limit");
const util_1 = require("util");
const snakeize = require('snakeize');
const acl_1 = require("./acl");
const file_1 = require("./file");
const iam_1 = require("./iam");
const notification_1 = require("./notification");
/**
 * The size of a file (in bytes) must be greater than this number to
 * automatically trigger a resumable upload.
 *
 * @const {number***REMOVED***
 * @private
 */
const RESUMABLE_THRESHOLD = 5000000;
/**
 * Create a Bucket object to interact with a Cloud Storage bucket.
 *
 * @class
 * @hideconstructor
 *
 * @param {Storage***REMOVED*** storage A {@link Storage***REMOVED*** instance.
 * @param {string***REMOVED*** name The name of the bucket.
 * @param {object***REMOVED*** [options] Configuration object.
 * @param {string***REMOVED*** [options.userProject] User project.
 *
 * @example
 * const {Storage***REMOVED*** = require('@google-cloud/storage');
 * const storage = new Storage();
 * const bucket = storage.bucket('albums');
 */
class Bucket extends common_1.ServiceObject {
    constructor(storage, name, options) {
        options = options || {***REMOVED***;
        // Allow for "gs://"-style input, and strip any trailing slashes.
        name = name.replace(/^gs:\/\//, '').replace(/\/+$/, '');
        const requestQueryObject = {***REMOVED***;
        const userProject = options.userProject;
        if (typeof userProject === 'string') {
            requestQueryObject.userProject = userProject;
      ***REMOVED***
        const methods = {
            /**
             * Create a bucket.
             *
             * @method Bucket#create
             * @param {CreateBucketRequest***REMOVED*** [metadata] Metadata to set for the bucket.
             * @param {CreateBucketCallback***REMOVED*** [callback] Callback function.
             * @returns {Promise<CreateBucketResponse>***REMOVED***
             *
             * @example
             * const {Storage***REMOVED*** = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             * bucket.create(function(err, bucket, apiResponse) {
             *   if (!err) {
             *     // The bucket was created successfully.
             * ***REMOVED***
             * ***REMOVED***);
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.create().then(function(data) {
             *   const bucket = data[0];
             *   const apiResponse = data[1];
             * ***REMOVED***);
             */
            create: {
                reqOpts: {
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef {object***REMOVED*** DeleteBucketOptions Configuration options.
             * @param {string***REMOVED*** [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef {array***REMOVED*** DeleteBucketResponse
             * @property {object***REMOVED*** 0 The full API response.
             */
            /**
             * @callback DeleteBucketCallback
             * @param {?Error***REMOVED*** err Request error, if any.
             * @param {object***REMOVED*** apiResponse The full API response.
             */
            /**
             * Delete the bucket.
             *
             * @see [Buckets: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/delete***REMOVED***
             *
             * @method Bucket#delete
             * @param {DeleteBucketOptions***REMOVED*** [options] Configuration options.
             * @param {DeleteBucketCallback***REMOVED*** [callback] Callback function.
             * @returns {Promise<DeleteBucketResponse>***REMOVED***
             *
             * @example
             * const {Storage***REMOVED*** = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             * bucket.delete(function(err, apiResponse) {***REMOVED***);
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.delete().then(function(data) {
             *   const apiResponse = data[0];
             * ***REMOVED***);
             *
             * @example <caption>include:samples/buckets.js</caption>
             * region_tag:storage_delete_bucket
             * Another example:
             */
            delete: {
                reqOpts: {
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef {object***REMOVED*** BucketExistsOptions Configuration options for Bucket#exists().
             * @param {string***REMOVED*** [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef {array***REMOVED*** BucketExistsResponse
             * @property {boolean***REMOVED*** 0 Whether the {@link Bucket***REMOVED*** exists.
             */
            /**
             * @callback BucketExistsCallback
             * @param {?Error***REMOVED*** err Request error, if any.
             * @param {boolean***REMOVED*** exists Whether the {@link Bucket***REMOVED*** exists.
             */
            /**
             * Check if the bucket exists.
             *
             * @method Bucket#exists
             * @param {BucketExistsOptions***REMOVED*** [options] Configuration options.
             * @param {BucketExistsCallback***REMOVED*** [callback] Callback function.
             * @returns {Promise<BucketExistsResponse>***REMOVED***
             *
             * @example
             * const {Storage***REMOVED*** = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * bucket.exists(function(err, exists) {***REMOVED***);
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.exists().then(function(data) {
             *   const exists = data[0];
             * ***REMOVED***);
             */
            exists: {
                reqOpts: {
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef {object***REMOVED*** [GetBucketOptions] Configuration options for Bucket#get()
             * @property {boolean***REMOVED*** [autoCreate] Automatically create the object if
             *     it does not exist. Default: `false`
             * @property {string***REMOVED*** [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef {array***REMOVED*** GetBucketResponse
             * @property {Bucket***REMOVED*** 0 The {@link Bucket***REMOVED***.
             * @property {object***REMOVED*** 1 The full API response.
             */
            /**
             * @callback GetBucketCallback
             * @param {?Error***REMOVED*** err Request error, if any.
             * @param {Bucket***REMOVED*** bucket The {@link Bucket***REMOVED***.
             * @param {object***REMOVED*** apiResponse The full API response.
             */
            /**
             * Get a bucket if it exists.
             *
             * You may optionally use this to "get or create" an object by providing
             * an object with `autoCreate` set to `true`. Any extra configuration that
             * is normally required for the `create` method must be contained within
             * this object as well.
             *
             * @method Bucket#get
             * @param {GetBucketOptions***REMOVED*** [options] Configuration options.
             * @param {GetBucketCallback***REMOVED*** [callback] Callback function.
             * @returns {Promise<GetBucketResponse>***REMOVED***
             *
             * @example
             * const {Storage***REMOVED*** = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * bucket.get(function(err, bucket, apiResponse) {
             *   // `bucket.metadata` has been populated.
             * ***REMOVED***);
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.get().then(function(data) {
             *   const bucket = data[0];
             *   const apiResponse = data[1];
             * ***REMOVED***);
             */
            get: {
                reqOpts: {
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef {array***REMOVED*** GetBucketMetadataResponse
             * @property {object***REMOVED*** 0 The bucket metadata.
             * @property {object***REMOVED*** 1 The full API response.
             */
            /**
             * @callback GetBucketMetadataCallback
             * @param {?Error***REMOVED*** err Request error, if any.
             * @param {object***REMOVED*** metadata The bucket metadata.
             * @param {object***REMOVED*** apiResponse The full API response.
             */
            /**
             * @typedef {object***REMOVED*** GetBucketMetadataOptions Configuration options for Bucket#getMetadata().
             * @property {string***REMOVED*** [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * Get the bucket's metadata.
             *
             * To set metadata, see {@link Bucket#setMetadata***REMOVED***.
             *
             * @see [Buckets: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/get***REMOVED***
             *
             * @method Bucket#getMetadata
             * @param {GetBucketMetadataOptions***REMOVED*** [options] Configuration options.
             * @param {GetBucketMetadataCallback***REMOVED*** [callback] Callback function.
             * @returns {Promise<GetBucketMetadataResponse>***REMOVED***
             *
             * @example
             * const {Storage***REMOVED*** = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * bucket.getMetadata(function(err, metadata, apiResponse) {***REMOVED***);
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.getMetadata().then(function(data) {
             *   const metadata = data[0];
             *   const apiResponse = data[1];
             * ***REMOVED***);
             *
             * @example <caption>include:samples/requesterPays.js</caption>
             * region_tag:storage_get_requester_pays_status
             * Example of retrieving the requester pays status of a bucket:
             */
            getMetadata: {
                reqOpts: {
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef {object***REMOVED*** SetBucketMetadataOptions Configuration options for Bucket#setMetadata().
             * @property {string***REMOVED*** [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef {array***REMOVED*** SetBucketMetadataResponse
             * @property {object***REMOVED*** apiResponse The full API response.
             */
            /**
             * @callback SetBucketMetadataCallback
             * @param {?Error***REMOVED*** err Request error, if any.
             * @param {object***REMOVED*** metadata The bucket metadata.
             */
            /**
             * Set the bucket's metadata.
             *
             * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch***REMOVED***
             *
             * @method Bucket#setMetadata
             * @param {object<string, *>***REMOVED*** metadata The metadata you wish to set.
             * @param {SetBucketMetadataOptions***REMOVED*** [options] Configuration options.
             * @param {SetBucketMetadataCallback***REMOVED*** [callback] Callback function.
             * @returns {Promise<SetBucketMetadataResponse>***REMOVED***
             *
             * @example
             * const {Storage***REMOVED*** = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * //-
             * // Set website metadata field on the bucket.
             * //-
             * const metadata = {
             *   website: {
             *     mainPageSuffix: 'http://example.com',
             *     notFoundPage: 'http://example.com/404.html'
             * ***REMOVED***
             * ***REMOVED***;
             *
             * bucket.setMetadata(metadata, function(err, apiResponse) {***REMOVED***);
             *
             * //-
             * // Enable versioning for your bucket.
             * //-
             * bucket.setMetadata({
             *   versioning: {
             *     enabled: true
             * ***REMOVED***
             * ***REMOVED***, function(err, apiResponse) {***REMOVED***);
             *
             * //-
             * // Enable KMS encryption for objects within this bucket.
             * //-
             * bucket.setMetadata({
             *   encryption: {
             *     defaultKmsKeyName: 'projects/grape-spaceship-123/...'
             * ***REMOVED***
             * ***REMOVED***, function(err, apiResponse) {***REMOVED***);
             *
             * //-
             * // Set the default event-based hold value for new objects in this
             * // bucket.
             * //-
             * bucket.setMetadata({
             *   defaultEventBasedHold: true
             * ***REMOVED***, function(err, apiResponse) {***REMOVED***);
             *
             * //-
             * // Remove object lifecycle rules.
             * //-
             * bucket.setMetadata({
             *   lifecycle: null
             * ***REMOVED***, function(err, apiResponse) {***REMOVED***);
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.setMetadata(metadata).then(function(data) {
             *   const apiResponse = data[0];
             * ***REMOVED***);
             */
            setMetadata: {
                reqOpts: {
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
      ***REMOVED***
        super({
            parent: storage,
            baseUrl: '/b',
            id: name,
            createMethod: storage.createBucket.bind(storage),
            methods,
      ***REMOVED***);
        this.name = name;
        this.storage = storage;
        this.userProject = options.userProject;
        this.acl = new acl_1.Acl({
            request: this.request.bind(this),
            pathPrefix: '/acl',
      ***REMOVED***);
        this.acl.default = new acl_1.Acl({
            request: this.request.bind(this),
            pathPrefix: '/defaultObjectAcl',
      ***REMOVED***);
        this.iam = new iam_1.Iam(this);
        this.getFilesStream = paginator_1.paginator.streamify('getFiles');
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** AddLifecycleRuleOptions Configuration options for Bucket#addLifecycleRule().
     * @property {string***REMOVED*** [append=true] The new rules will be appended to any
     *     pre-existing rules.
     */
    /**
     * Add an object lifecycle management rule to the bucket.
     *
     * By default, an Object Lifecycle Management rule provided to this method
     * will be included to the existing policy. To replace all existing rules,
     * supply the `options` argument, setting `append` to `false`.
     *
     * @see [Object Lifecycle Management]{@link https://cloud.google.com/storage/docs/lifecycle***REMOVED***
     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch***REMOVED***
     *
     * @param {LifecycleRule***REMOVED*** rule The new lifecycle rule to be added to objects
     *     in this bucket.
     * @param {string***REMOVED*** [rule.storageClass] When using the `setStorageClass`
     *     action, provide this option to dictate which storage class the object
     *     should update to.
     * @param {AddLifecycleRuleOptions***REMOVED*** [options] Configuration object.
     * @param {boolean***REMOVED*** [options.append=true] Append the new rule to the existing
     *     policy.
     * @param {SetBucketMetadataCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<SetBucketMetadataResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Automatically have an object deleted from this bucket once it is 3 years
     * // of age.
     * //-
     * bucket.addLifecycleRule({
     *   action: 'delete',
     *   condition: {
     *     age: 365 * 3 // Specified in days.
     * ***REMOVED***
     * ***REMOVED***, function(err, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   const lifecycleRules = bucket.metadata.lifecycle.rule;
     *
     *   // Iterate over the Object Lifecycle Management rules on this bucket.
     *   lifecycleRules.forEach(lifecycleRule => {***REMOVED***);
     * ***REMOVED***);
     *
     * //-
     * // By default, the rule you provide will be added to the existing policy.
     * // Optionally, you can disable this behavior to replace all of the
     * // pre-existing rules.
     * //-
     * const options = {
     *   append: false
     * ***REMOVED***;
     *
     * bucket.addLifecycleRule({
     *   action: 'delete',
     *   condition: {
     *     age: 365 * 3 // Specified in days.
     * ***REMOVED***
     * ***REMOVED***, options, function(err, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   // All rules have been replaced with the new "delete" rule.
     *
     *   // Iterate over the Object Lifecycle Management rules on this bucket.
     *   lifecycleRules.forEach(lifecycleRule => {***REMOVED***);
     * ***REMOVED***);
     *
     * //-
     * // For objects created before 2018, "downgrade" the storage class.
     * //-
     * bucket.addLifecycleRule({
     *   action: 'setStorageClass',
     *   storageClass: 'COLDLINE',
     *   condition: {
     *     createdBefore: new Date('2018')
     * ***REMOVED***
     * ***REMOVED***, function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // Delete objects created before 2016 which have the Coldline storage
     * // class.
     * //-
     * bucket.addLifecycleRule({
     *   action: 'delete',
     *   condition: {
     *     matchesStorageClass: [
     *       'COLDLINE'
     *     ],
     *     createdBefore: new Date('2016')
     * ***REMOVED***
     * ***REMOVED***, function(err, apiResponse) {***REMOVED***);
     */
    addLifecycleRule(rule, optionsOrCallback, callback) {
        let options;
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) {
            options = optionsOrCallback;
      ***REMOVED***
        options = options || {***REMOVED***;
        callback = callback || common_1.util.noop;
        const newLifecycleRules = arrify(rule).map(rule => {
            if (typeof rule.action === 'object') {
                // This is a raw-formatted rule object, the way the API expects.
                // Just pass it through as-is.
                return rule;
          ***REMOVED***
            const apiFormattedRule = {***REMOVED***;
            apiFormattedRule.condition = {***REMOVED***;
            apiFormattedRule.action = {
                type: rule.action,
          ***REMOVED***
            // @TODO: Remove if the API becomes less picky.
            if (rule.action === 'delete') {
                apiFormattedRule.action.type = 'Delete';
          ***REMOVED***
            if (rule.storageClass) {
                apiFormattedRule.action.storageClass = rule.storageClass;
          ***REMOVED***
            for (const condition in rule.condition) {
                if (rule.condition[condition] instanceof Date) {
                    apiFormattedRule.condition[condition] = rule.condition[condition]
                        .toISOString()
                        .replace(/T.+$/, '');
              ***REMOVED***
                else {
                    apiFormattedRule.condition[condition] = rule.condition[condition];
              ***REMOVED***
          ***REMOVED***
            return apiFormattedRule;
      ***REMOVED***);
        if (options.append === false) {
            this.setMetadata({ lifecycle: { rule: newLifecycleRules ***REMOVED*** ***REMOVED***, callback);
            return;
      ***REMOVED***
        // The default behavior appends the previously-defined lifecycle rules with
        // the new ones just passed in by the user.
        this.getMetadata((err, metadata) => {
            if (err) {
                callback(err);
                return;
          ***REMOVED***
            const currentLifecycleRules = arrify(metadata.lifecycle && metadata.lifecycle.rule);
            this.setMetadata({
                lifecycle: {
                    rule: currentLifecycleRules.concat(newLifecycleRules),
              ***REMOVED***,
          ***REMOVED***, callback);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** CombineOptions
     * @property {string***REMOVED*** [kmsKeyName] Resource name of the Cloud KMS key, of
     *     the form
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,
     *     that will be used to encrypt the object. Overwrites the object
     * metadata's `kms_key_name` value, if any.
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback CombineCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {File***REMOVED*** newFile The new {@link File***REMOVED***.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * @typedef {array***REMOVED*** CombineResponse
     * @property {File***REMOVED*** 0 The new {@link File***REMOVED***.
     * @property {object***REMOVED*** 1 The full API response.
     */
    /**
     * Combine multiple files into one new file.
     *
     * @see [Objects: compose API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/compose***REMOVED***
     *
     * @throws {Error***REMOVED*** if a non-array is provided as sources argument.
     * @throws {Error***REMOVED*** if less than two sources are provided.
     * @throws {Error***REMOVED*** if no destination is provided.
     *
     * @param {string[]|File[]***REMOVED*** sources The source files that will be
     *     combined.
     * @param {string|File***REMOVED*** destination The file you would like the
     *     source files combined into.
     * @param {CombineOptions***REMOVED*** [options] Configuration options.
     * @param {CombineCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<CombineResponse>***REMOVED***
     *
     * @example
     * const logBucket = storage.bucket('log-bucket');
     *
     * const sources = [
     *   logBucket.file('2013-logs.txt'),
     *   logBucket.file('2014-logs.txt')
     * ];
     *
     * const allLogs = logBucket.file('all-logs.txt');
     *
     * logBucket.combine(sources, allLogs, function(err, newFile, apiResponse) {
     *   // newFile === allLogs
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logBucket.combine(sources, allLogs).then(function(data) {
     *   const newFile = data[0];
     *   const apiResponse = data[1];
     * ***REMOVED***);
     */
    combine(sources, destination, optionsOrCallback, callback) {
        if (!Array.isArray(sources) || sources.length < 2) {
            throw new Error('You must provide at least two source files.');
      ***REMOVED***
        if (!destination) {
            throw new Error('A destination file must be specified.');
      ***REMOVED***
        let options = {***REMOVED***;
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) {
            options = optionsOrCallback;
      ***REMOVED***
        const convertToFile = (file) => {
            if (file instanceof file_1.File) {
                return file;
          ***REMOVED***
            return this.file(file);
      ***REMOVED***
        // tslint:disable-next-line:no-any
        sources = sources.map(convertToFile);
        const destinationFile = convertToFile(destination);
        callback = callback || common_1.util.noop;
        if (!destinationFile.metadata.contentType) {
            const destinationContentType = mime.contentType(destinationFile.name);
            if (destinationContentType) {
                destinationFile.metadata.contentType = destinationContentType;
          ***REMOVED***
      ***REMOVED***
        // Make the request from the destination File object.
        destinationFile.request({
            method: 'POST',
            uri: '/compose',
            json: {
                destination: {
                    contentType: destinationFile.metadata.contentType,
              ***REMOVED***,
                sourceObjects: sources.map(source => {
                    const sourceObject = {
                        name: source.name,
                  ***REMOVED***
                    if (source.metadata && source.metadata.generation) {
                        sourceObject.generation = source.metadata.generation;
                  ***REMOVED***
                    return sourceObject;
              ***REMOVED***),
          ***REMOVED***,
            qs: options,
      ***REMOVED***, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
          ***REMOVED***
            callback(null, destinationFile, resp);
      ***REMOVED***);
  ***REMOVED***
    /**
     * See a [Objects:
     * watchAll request
     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll).
     *
     * @typedef {object***REMOVED*** CreateChannelConfig
     * @property {string***REMOVED*** address The address where notifications are
     *     delivered for this channel.
     * @extends WatchAllOptions
     */
    /**
     * @typedef {object***REMOVED*** CreateChannelOptions
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @typedef {array***REMOVED*** CreateChannelResponse
     * @property {Channel***REMOVED*** 0 The new {@link Channel***REMOVED***.
     * @property {object***REMOVED*** 1 The full API response.
     */
    /**
     * @callback CreateChannelCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {Channel***REMOVED*** channel The new {@link Channel***REMOVED***.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * Create a channel that will be notified when objects in this bucket changes.
     *
     * @throws {Error***REMOVED*** If an ID is not provided.
     * @throws {Error***REMOVED*** If an address is not provided.
     *
     * @see [Objects: watchAll API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll***REMOVED***
     *
     * @param {string***REMOVED*** id The ID of the channel to create.
     * @param {CreateChannelConfig***REMOVED*** config Configuration for creating channel.
     * @param {CreateChannelOptions***REMOVED*** [options] Configuration options.
     * @param {CreateChannelCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<CreateChannelResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     * const id = 'new-channel-id';
     *
     * ***REMOVED***
     *   address: 'https://...'
     * ***REMOVED***;
     *
     * bucket.createChannel(id, config, function(err, channel, apiResponse) {
     *   if (!err) {
     *     // Channel created successfully.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.createChannel(id, config).then(function(data) {
     *   const channel = data[0];
     *   const apiResponse = data[1];
     * ***REMOVED***);
     */
    createChannel(id, config, optionsOrCallback, callback) {
        if (typeof id !== 'string') {
            throw new Error('An ID is required to create a channel.');
      ***REMOVED***
        if (typeof config.address !== 'string') {
            throw new Error('An address is required to create a channel.');
      ***REMOVED***
        let options = {***REMOVED***;
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) {
            options = optionsOrCallback;
      ***REMOVED***
        this.request({
            method: 'POST',
            uri: '/o/watch',
            json: Object.assign({
                id,
                type: 'web_hook',
          ***REMOVED***, config),
            qs: options,
      ***REMOVED***, (err, apiResponse) => {
            if (err) {
                callback(err, null, apiResponse);
                return;
          ***REMOVED***
            const resourceId = apiResponse.resourceId;
            const channel = this.storage.channel(id, resourceId);
            channel.metadata = apiResponse;
            callback(null, channel, apiResponse);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Metadata to set for the Notification.
     *
     * @typedef {object***REMOVED*** CreateNotificationOptions
     * @property {object***REMOVED*** [customAttributes] An optional list of additional
     *     attributes to attach to each Cloud PubSub message published for this
     *     notification subscription.
     * @property {string[]***REMOVED*** [eventTypes] If present, only send notifications about
     *     listed event types. If empty, sent notifications for all event types.
     * @property {string***REMOVED*** [objectNamePrefix] If present, only apply this
     *     notification configuration to object names that begin with this prefix.
     * @property {string***REMOVED*** [payloadFormat] The desired content of the Payload.
     *     Defaults to `JSON_API_V1`.
     *
     *     Acceptable values are:
     *     - `JSON_API_V1`
     *
     *     - `NONE`
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback CreateNotificationCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {Notification***REMOVED*** notification The new {@link Notification***REMOVED***.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * @typedef {array***REMOVED*** CreateNotificationResponse
     * @property {Notification***REMOVED*** 0 The new {@link Notification***REMOVED***.
     * @property {object***REMOVED*** 1 The full API response.
     */
    /**
     * Creates a notification subscription for the bucket.
     *
     * @see [Notifications: insert]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/insert***REMOVED***
     *
     * @param {Topic|string***REMOVED*** topic The Cloud PubSub topic to which this
     *     subscription publishes. If the project ID is omitted, the current
     * project ID will be used.
     *
     *     Acceptable formats are:
     *     - `projects/grape-spaceship-123/topics/my-topic`
     *
     *     - `my-topic`
     * @param {CreateNotificationOptions***REMOVED*** [options] Metadata to set for the
     *     notification.
     * @param {CreateNotificationCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<CreateNotificationResponse>***REMOVED***
     * @throws {Error***REMOVED*** If a valid topic is not provided.
     * @see Notification#create
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const myBucket = storage.bucket('my-bucket');
     *
     * const callback = function(err, notification, apiResponse) {
     *   if (!err) {
     *     // The notification was created successfully.
     * ***REMOVED***
     * ***REMOVED***;
     *
     * myBucket.createNotification('my-topic', callback);
     *
     * //-
     * // Configure the nofiication by providing Notification metadata.
     * //-
     * const metadata = {
     *   objectNamePrefix: 'prefix-'
     * ***REMOVED***;
     *
     * myBucket.createNotification('my-topic', metadata, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * myBucket.createNotification('my-topic').then(function(data) {
     *   const notification = data[0];
     *   const apiResponse = data[1];
     * ***REMOVED***);
     *
     * @example <caption>include:samples/notifications.js</caption>
     * region_tag:storage_create_notification
     * Another example:
     */
    createNotification(topic, optionsOrCallback, callback) {
        let options = {***REMOVED***;
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) {
            options = optionsOrCallback;
      ***REMOVED***
        const topicIsObject = topic !== null && typeof topic === 'object';
        if (topicIsObject && common_1.util.isCustomType(topic, 'pubsub/topic')) {
            // tslint:disable-next-line:no-any
            topic = topic.name;
      ***REMOVED***
        if (typeof topic !== 'string') {
            throw new Error('A valid topic name is required.');
      ***REMOVED***
        const body = Object.assign({ topic ***REMOVED***, options);
        if (body.topic.indexOf('projects') !== 0) {
            body.topic = 'projects/{{projectId***REMOVED******REMOVED***/topics/' + body.topic;
      ***REMOVED***
        body.topic = '//pubsub.googleapis.com/' + body.topic;
        if (!body.payloadFormat) {
            body.payloadFormat = 'JSON_API_V1';
      ***REMOVED***
        const query = {***REMOVED***;
        if (body.userProject) {
            query.userProject = body.userProject;
            delete body.userProject;
      ***REMOVED***
        this.request({
            method: 'POST',
            uri: '/notificationConfigs',
            json: snakeize(body),
            qs: query,
      ***REMOVED***, (err, apiResponse) => {
            if (err) {
                callback(err, null, apiResponse);
                return;
          ***REMOVED***
            const notification = this.notification(apiResponse.id);
            notification.metadata = apiResponse;
            callback(null, notification, apiResponse);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** DeleteFilesOptions Query object. See {@link Bucket#getFiles***REMOVED***
     *     for all of the supported properties.
     * @property {boolean***REMOVED*** [force] Suppress errors until all files have been
     *     processed.
     */
    /**
     * @callback DeleteFilesCallback
     * @param {?Error|?Error[]***REMOVED*** err Request error, if any, or array of errors from
     *     files that were not able to be deleted.
     * @param {object***REMOVED*** [apiResponse] The full API response.
     */
    /**
     * Iterate over the bucket's files, calling `file.delete()` on each.
     *
     * <strong>This is not an atomic request.</strong> A delete attempt will be
     * made for each file individually. Any one can fail, in which case only a
     * portion of the files you intended to be deleted would have.
     *
     * Operations are performed in parallel, up to 10 at once. The first error
     * breaks the loop and will execute the provided callback with it. Specify
     * `{ force: true ***REMOVED***` to suppress the errors until all files have had a chance
     * to be processed.
     *
     * The `query` object passed as the first argument will also be passed to
     * {@link Bucket#getFiles***REMOVED***.
     *
     * @see [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete***REMOVED***
     *
     * @param {DeleteFilesOptions***REMOVED*** [query] Query object. See {@link Bucket#getFiles***REMOVED***
     * @param {DeleteFilesCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Delete all of the files in the bucket.
     * //-
     * bucket.deleteFiles(function(err) {***REMOVED***);
     *
     * //-
     * // By default, if a file cannot be deleted, this method will stop deleting
     * // files from your bucket. You can override this setting with `force:
     * // true`.
     * //-
     * bucket.deleteFiles({
     *   force: true
     * ***REMOVED***, function(errors) {
     *   // `errors`:
     *   //    Array of errors if any occurred, otherwise null.
     * ***REMOVED***);
     *
     * //-
     * // The first argument to this method acts as a query to
     * // {@link Bucket#getFiles***REMOVED***. As an example, you can delete files
     * // which match a prefix.
     * //-
     * bucket.deleteFiles({
     *   prefix: 'images/'
     * ***REMOVED***, function(err) {
     *   if (!err) {
     *     // All files in the `images` directory have been deleted.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.deleteFiles().then(function() {***REMOVED***);
     */
    deleteFiles(queryOrCallback, callback) {
        let query = {***REMOVED***;
        if (typeof queryOrCallback === 'function') {
            callback = queryOrCallback;
      ***REMOVED***
        else if (queryOrCallback) {
            query = queryOrCallback;
      ***REMOVED***
        const MAX_PARALLEL_LIMIT = 10;
        const errors = [];
        const deleteFile = (file) => {
            return file.delete(query).catch(err => {
                if (!query.force) {
                    throw err;
              ***REMOVED***
                errors.push(err);
          ***REMOVED***);
      ***REMOVED***
        this.getFiles(query)
            .then(([files]) => {
            const limit = p_limit_1.default(MAX_PARALLEL_LIMIT);
            const promises = files.map(file => {
                return limit(() => deleteFile(file));
          ***REMOVED***);
            return Promise.all(promises);
      ***REMOVED***)
            .then(() => callback(errors.length > 0 ? errors : null), callback);
  ***REMOVED***
    /**
     * @typedef {array***REMOVED*** DeleteLabelsResponse
     * @property {object***REMOVED*** 0 The full API response.
     */
    /**
     * @callback DeleteLabelsCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** metadata Bucket's metadata.
     */
    /**
     * Delete one or more labels from this bucket.
     *
     * @param {string|string[]***REMOVED*** labels The labels to delete. If no labels are
     *     provided, all of the labels are removed.
     * @param {DeleteLabelsCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<DeleteLabelsResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Delete all of the labels from this bucket.
     * //-
     * bucket.deleteLabels(function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // Delete a single label.
     * //-
     * bucket.deleteLabels('labelone', function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // Delete a specific set of labels.
     * //-
     * bucket.deleteLabels([
     *   'labelone',
     *   'labeltwo'
     * ], function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.deleteLabels().then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     */
    deleteLabels(labelsOrCallback, callback) {
        let labels = new Array();
        if (typeof labelsOrCallback === 'function') {
            callback = labelsOrCallback;
      ***REMOVED***
        else if (labelsOrCallback) {
            labels = arrify(labelsOrCallback);
      ***REMOVED***
        const deleteLabels = (labels) => {
            const nullLabelMap = labels.reduce((nullLabelMap, labelKey) => {
                nullLabelMap[labelKey] = null;
                return nullLabelMap;
          ***REMOVED***, {***REMOVED***);
            this.setLabels(nullLabelMap, callback);
      ***REMOVED***
        if (labels.length === 0) {
            this.getLabels((err, labels) => {
                if (err) {
                    callback(err);
                    return;
              ***REMOVED***
                deleteLabels(Object.keys(labels));
          ***REMOVED***);
      ***REMOVED***
        else {
            deleteLabels(labels);
      ***REMOVED***
  ***REMOVED***
    /**
     * @typedef {array***REMOVED*** DisableRequesterPaysResponse
     * @property {object***REMOVED*** 0 The full API response.
     */
    /**
     * @callback DisableRequesterPaysCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * <div class="notice">
     *   <strong>Early Access Testers Only</strong>
     *   <p>
     *     This feature is not yet widely-available.
     *   </p>
     * </div>
     *
     * Disable `requesterPays` functionality from this bucket.
     *
     * @param {DisableRequesterPaysCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<DisableRequesterPaysCallback>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.disableRequesterPays(function(err, apiResponse) {
     *   if (!err) {
     *     // requesterPays functionality disabled successfully.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.disableRequesterPays().then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     *
     * @example <caption>include:samples/requesterPays.js</caption>
     * region_tag:storage_disable_requester_pays
     * Example of disabling requester pays:
     */
    disableRequesterPays(callback) {
        this.setMetadata({
            billing: {
                requesterPays: false,
          ***REMOVED***,
      ***REMOVED***, callback || common_1.util.noop);
  ***REMOVED***
    /**
     * Configuration object for enabling logging.
     *
     * @typedef {object***REMOVED*** EnableLoggingOptions
     * @property {string|Bucket***REMOVED*** [bucket] The bucket for the log entries. By
     *     default, the current bucket is used.
     * @property {string***REMOVED*** prefix A unique prefix for log object names.
     */
    /**
     * Enable logging functionality for this bucket. This will make two API
     * requests, first to grant Cloud Storage WRITE permission to the bucket, then
     * to set the appropriate configuration on the Bucket's metadata.
     *
     * @param {EnableLoggingOptions***REMOVED*** config Configuration options.
     * @param {SetBucketMetadataCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<SetBucketMetadataResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * ***REMOVED***
     *   prefix: 'log'
     * ***REMOVED***;
     *
     * bucket.enableLogging(config, function(err, apiResponse) {
     *   if (!err) {
     *     // Logging functionality enabled successfully.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * @example <caption>Optionally, provide a destination bucket.</caption>
     * ***REMOVED***
     *   prefix: 'log',
     *   bucket: 'destination-bucket'
     * ***REMOVED***;
     *
     * bucket.enableLogging(config, function(err, apiResponse) {***REMOVED***);
     *
     * @example <caption>If the callback is omitted, we'll return a Promise.</caption>
     * bucket.enableLogging(config).then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     */
    enableLogging(config, callback) {
        if (!config ||
            typeof config === 'function' ||
            typeof config.prefix === 'undefined') {
            throw new Error('A configuration object with a prefix is required.');
      ***REMOVED***
        const logBucket = config.bucket
            ? config.bucket.id || config.bucket
            : this.id;
        (async () => {
            let setMetadataResponse;
            try {
                const [policy] = await this.iam.getPolicy();
                policy.bindings.push({
                    members: ['group:cloud-storage-analytics@google.com'],
                    role: 'roles/storage.objectCreator',
              ***REMOVED***);
                await this.iam.setPolicy(policy);
                [setMetadataResponse] = await this.setMetadata({
                    logging: {
                        logBucket,
                        logObjectPrefix: config.prefix,
                  ***REMOVED***,
              ***REMOVED***);
          ***REMOVED***
            catch (e) {
                callback(e);
                return;
          ***REMOVED***
            callback(null, setMetadataResponse);
      ***REMOVED***)();
  ***REMOVED***
    /**
     * @typedef {array***REMOVED*** EnableRequesterPaysResponse
     * @property {object***REMOVED*** 0 The full API response.
     */
    /**
     * @callback EnableRequesterPaysCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * <div class="notice">
     *   <strong>Early Access Testers Only</strong>
     *   <p>
     *     This feature is not yet widely-available.
     *   </p>
     * </div>
     *
     * Enable `requesterPays` functionality for this bucket. This enables you, the
     * bucket owner, to have the requesting user assume the charges for the access
     * to your bucket and its contents.
     *
     * @param {EnableRequesterPaysCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<EnableRequesterPaysResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.enableRequesterPays(function(err, apiResponse) {
     *   if (!err) {
     *     // requesterPays functionality enabled successfully.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.enableRequesterPays().then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     *
     * @example <caption>include:samples/requesterPays.js</caption>
     * region_tag:storage_enable_requester_pays
     * Example of enabling requester pays:
     */
    enableRequesterPays(callback) {
        this.setMetadata({
            billing: {
                requesterPays: true,
          ***REMOVED***,
      ***REMOVED***, callback || common_1.util.noop);
  ***REMOVED***
    /**
     * Create a {@link File***REMOVED*** object. See {@link File***REMOVED*** to see how to handle
     * the different use cases you may have.
     *
     * @param {string***REMOVED*** name The name of the file in this bucket.
     * @param {object***REMOVED*** [options] Configuration options.
     * @param {string|number***REMOVED*** [options.generation] Only use a specific revision of
     *     this file.
     * @param {string***REMOVED*** [options.encryptionKey] A custom encryption key. See
     *     [Customer-supplied Encryption
     * Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).
     * @param {string***REMOVED*** [options.kmsKeyName] The name of the Cloud KMS key that will
     *     be used to encrypt the object. Must be in the format:
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.
     *     KMS key ring must use the same location as the bucket.
     * @returns {File***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     * const file = bucket.file('my-existing-file.png');
     */
    file(name, options) {
        if (!name) {
            throw Error('A file name must be specified.');
      ***REMOVED***
        return new file_1.File(this, name, options);
  ***REMOVED***
    /**
     * @typedef {array***REMOVED*** GetFilesResponse
     * @property {File[]***REMOVED*** 0 Array of {@link File***REMOVED*** instances.
     */
    /**
     * @callback GetFilesCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {File[]***REMOVED*** files Array of {@link File***REMOVED*** instances.
     */
    /**
     * Query object for listing files.
     *
     * @typedef {object***REMOVED*** GetFilesOptions
     * @property {boolean***REMOVED*** [autoPaginate=true] Have pagination handled
     *     automatically.
     * @property {string***REMOVED*** [delimiter] Results will contain only objects whose
     *     names, aside from the prefix, do not contain delimiter. Objects whose
     *     names, aside from the prefix, contain delimiter will have their name
     *     truncated after the delimiter, returned in `apiResponse.prefixes`.
     *     Duplicate prefixes are omitted.
     * @property {string***REMOVED*** [directory] Filter results based on a directory name, or
     *     more technically, a "prefix".
     * @property {string***REMOVED*** [prefix] Filter results to objects whose names begin
     *     with this prefix.
     * @property {number***REMOVED*** [maxApiCalls] Maximum number of API calls to make.
     * @property {number***REMOVED*** [maxResults] Maximum number of items plus prefixes to
     *     return.
     * @property {string***REMOVED*** [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     * @property {boolean***REMOVED*** [versions] If true, returns File objects scoped to
     *     their versions.
     */
    /**
     * Get {@link File***REMOVED*** objects for the files currently in the bucket.
     *
     * @see [Objects: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/list***REMOVED***
     *
     * @param {GetFilesOptions***REMOVED*** [query] Query object for listing files.
     * @param {GetFilesCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<GetFilesResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.getFiles(function(err, files) {
     *   if (!err) {
     *     // files is an array of File objects.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If your bucket has versioning enabled, you can get all of your files
     * // scoped to their generation.
     * //-
     * bucket.getFiles({
     *   versions: true
     * ***REMOVED***, function(err, files) {
     *   // Each file is scoped to its generation.
     * ***REMOVED***);
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * const callback = function(err, files, nextQuery, apiResponse) {
     *   if (nextQuery) {
     *     // More results exist.
     *     bucket.getFiles(nextQuery, callback);
     * ***REMOVED***
     *
     *   // The `metadata` property is populated for you with the metadata at the
     *   // time of fetching.
     *   files[0].metadata;
     *
     *   // However, in cases where you are concerned the metadata could have
     *   // changed, use the `getMetadata` method.
     *   files[0].getMetadata(function(err, metadata) {***REMOVED***);
     * ***REMOVED***;
     *
     * bucket.getFiles({
     *   autoPaginate: false
     * ***REMOVED***, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getFiles().then(function(data) {
     *   const files = data[0];
     * ***REMOVED***);
     *
     * @example <caption>include:samples/files.js</caption>
     * region_tag:storage_list_files
     * Another example:
     *
     * @example <caption>include:samples/files.js</caption>
     * region_tag:storage_list_files_with_prefix
     * Example of listing files, filtered by a prefix:
     */
    getFiles(queryOrCallback, callback) {
        let query = typeof queryOrCallback === 'object' ? queryOrCallback : {***REMOVED***;
        if (!callback) {
            callback = queryOrCallback;
      ***REMOVED***
        query = Object.assign({***REMOVED***, query);
        if (query.directory) {
            query.prefix = `${query.directory***REMOVED***/`.replace(/\/*$/, '/');
            delete query.directory;
      ***REMOVED***
        this.request({
            uri: '/o',
            qs: query,
      ***REMOVED***, (err, resp) => {
            if (err) {
                // tslint:disable-next-line:no-any
                callback(err, null, null, resp);
                return;
          ***REMOVED***
            const files = arrify(resp.items).map((file) => {
                const options = {***REMOVED***;
                if (query.versions) {
                    options.generation = file.generation;
              ***REMOVED***
                if (file.kmsKeyName) {
                    options.kmsKeyName = file.kmsKeyName;
              ***REMOVED***
                const fileInstance = this.file(file.name, options);
                fileInstance.metadata = file;
                return fileInstance;
          ***REMOVED***);
            let nextQuery = null;
            if (resp.nextPageToken) {
                nextQuery = Object.assign({***REMOVED***, query, {
                    pageToken: resp.nextPageToken,
              ***REMOVED***);
          ***REMOVED***
            // tslint:disable-next-line:no-any
            callback(null, files, nextQuery, resp);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** GetLabelsOptions Configuration options for Bucket#getLabels().
     * @param {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @typedef {array***REMOVED*** GetLabelsResponse
     * @property {object***REMOVED*** 0 Object of labels currently set on this bucket.
     */
    /**
     * @callback GetLabelsCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** labels Object of labels currently set on this bucket.
     */
    /**
     * Get the labels currently set on this bucket.
     *
     * @param {object***REMOVED*** [options] Configuration options.
     * @param {string***REMOVED*** [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param {GetLabelsCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<GetLabelsCallback>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.getLabels(function(err, labels) {
     *   if (err) {
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   // labels = {
     *   //   label: 'labelValue',
     *   //   ...
     *   // ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getLabels().then(function(data) {
     *   const labels = data[0];
     * ***REMOVED***);
     */
    getLabels(optionsOrCallback, callback) {
        let options = {***REMOVED***;
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) {
            options = optionsOrCallback;
      ***REMOVED***
        this.getMetadata(options, (err, metadata) => {
            if (err) {
                callback(err, null);
                return;
          ***REMOVED***
            callback(null, metadata.labels || {***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** GetNotificationOptions Configuration options for Bucket#getNotification().
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback GetNotificationsCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {Notification[]***REMOVED*** notifications Array of {@link Notification***REMOVED***
     *     instances.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * @typedef {array***REMOVED*** GetNotificationsResponse
     * @property {Notification[]***REMOVED*** 0 Array of {@link Notification***REMOVED*** instances.
     * @property {object***REMOVED*** 1 The full API response.
     */
    /**
     * Retrieves a list of notification subscriptions for a given bucket.
     *
     * @see [Notifications: list]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/list***REMOVED***
     *
     * @param {GetNotificationsOptions***REMOVED*** [options] Configuration options.
     * @param {GetNotificationsCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<GetNotificationsResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('my-bucket');
     *
     * bucket.getNotifications(function(err, notifications, apiResponse) {
     *   if (!err) {
     *     // notifications is an array of Notification objects.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getNotifications().then(function(data) {
     *   const notifications = data[0];
     *   const apiResponse = data[1];
     * ***REMOVED***);
     *
     * @example <caption>include:samples/notifications.js</caption>
     * region_tag:storage_list_notifications
     * Another example:
     */
    getNotifications(optionsOrCallback, callback) {
        let options = {***REMOVED***;
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) {
            options = optionsOrCallback;
      ***REMOVED***
        this.request({
            uri: '/notificationConfigs',
            qs: options,
      ***REMOVED***, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
          ***REMOVED***
            const notifications = arrify(resp.items).map((notification) => {
                const notificationInstance = this.notification(notification.id);
                notificationInstance.metadata = notification;
                return notificationInstance;
          ***REMOVED***);
            callback(null, notifications, resp);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @callback BucketLockCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * Lock a previously-defined retention policy. This will prevent changes to
     * the policy.
     *
     * @throws {Error***REMOVED*** if a metageneration is not provided.
     *
     * @param {Number|String***REMOVED*** metageneration The bucket's metageneration. This is
     *     accesssible from calling {@link File#getMetadata***REMOVED***.
     * @param {BucketLockCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<BucketLockResponse>***REMOVED***
     *
     * @example
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * const metageneration = 2;
     *
     * bucket.lock(metageneration, function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.lock(metageneration).then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     */
    lock(metageneration, callback) {
        const metatype = typeof metageneration;
        if (metatype !== 'number' && metatype !== 'string') {
            throw new Error('A metageneration must be provided.');
      ***REMOVED***
        this.request({
            method: 'POST',
            uri: '/lockRetentionPolicy',
            qs: {
                ifMetagenerationMatch: metageneration,
          ***REMOVED***,
      ***REMOVED***, callback);
  ***REMOVED***
    /**
     * @typedef {array***REMOVED*** MakeBucketPrivateResponse
     * @property {File[]***REMOVED*** 0 List of files made private.
     */
    /**
     * @callback MakeBucketPrivateCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {File[]***REMOVED*** files List of files made private.
     */
    /**
     * @typedef {object***REMOVED*** MakeBucketPrivateOptions
     * @param {boolean***REMOVED*** [includeFiles=false] Make each file in the bucket
     *     private.
     * @param {boolean***REMOVED*** [force] Queue errors occurred while making files
     *     private until all files have been processed.
     * @param {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * Make the bucket listing private.
     *
     * You may also choose to make the contents of the bucket private by
     * specifying `includeFiles: true`. This will automatically run
     * {@link File#makePrivate***REMOVED*** for every file in the bucket.
     *
     * When specifying `includeFiles: true`, use `force: true` to delay execution
     * of your callback until all files have been processed. By default, the
     * callback is executed after the first error. Use `force` to queue such
     * errors until all files have been processed, after which they will be
     * returned as an array as the first argument to your callback.
     *
     * NOTE: This may cause the process to be long-running and use a high number
     * of requests. Use with caution.
     *
     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch***REMOVED***
     *
     * @param {MakeBucketPrivateOptions***REMOVED*** [options] Configuration options.
     * @param {MakeBucketPrivateCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<MakeBucketPrivateResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Make the bucket private.
     * //-
     * bucket.makePrivate(function(err) {***REMOVED***);
     *
     * //-
     * // Make the bucket and its contents private.
     * //-
     * const opts = {
     *   includeFiles: true
     * ***REMOVED***;
     *
     * bucket.makePrivate(opts, function(err, files) {
     *   // `err`:
     *   //    The first error to occur, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made private in the bucket.
     * ***REMOVED***);
     *
     * //-
     * // Make the bucket and its contents private, using force to suppress errors
     * // until all files have been processed.
     * //-
     * const opts = {
     *   includeFiles: true,
     *   force: true
     * ***REMOVED***;
     *
     * bucket.makePrivate(opts, function(errors, files) {
     *   // `errors`:
     *   //    Array of errors if any occurred, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made private in the bucket.
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.makePrivate(opts).then(function(data) {
     *   const files = data[0];
     * ***REMOVED***);
     */
    makePrivate(optionsOrCallback, callback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {***REMOVED***;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        options.private = true;
        const query = {
            predefinedAcl: 'projectPrivate',
      ***REMOVED***
        if (options.userProject) {
            query.userProject = options.userProject;
      ***REMOVED***
        this.setMetadata({
            // You aren't allowed to set both predefinedAcl & acl properties on
            // a bucket so acl must explicitly be nullified.
            acl: null,
      ***REMOVED***, query)
            .then(() => {
            if (options.includeFiles) {
                return util_1.promisify(this.makeAllFilesPublicPrivate_).call(this, options);
          ***REMOVED***
            return [];
      ***REMOVED***)
            .then(files => callback(null, files), callback);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** MakeBucketPublicOptions
     * @param {boolean***REMOVED*** [includeFiles=false] Make each file in the bucket
     *     private.
     * @param {boolean***REMOVED*** [force] Queue errors occurred while making files
     *     private until all files have been processed.
     */
    /**
     * @callback MakeBucketPublicCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {File[]***REMOVED*** files List of files made public.
     */
    /**
     * @typedef {array***REMOVED*** MakeBucketPublicResponse
     * @property {File[]***REMOVED*** 0 List of files made public.
     */
    /**
     * Make the bucket publicly readable.
     *
     * You may also choose to make the contents of the bucket publicly readable by
     * specifying `includeFiles: true`. This will automatically run
     * {@link File#makePublic***REMOVED*** for every file in the bucket.
     *
     * When specifying `includeFiles: true`, use `force: true` to delay execution
     * of your callback until all files have been processed. By default, the
     * callback is executed after the first error. Use `force` to queue such
     * errors until all files have been processed, after which they will be
     * returned as an array as the first argument to your callback.
     *
     * NOTE: This may cause the process to be long-running and use a high number
     * of requests. Use with caution.
     *
     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch***REMOVED***
     *
     * @param {MakeBucketPublicOptions***REMOVED*** [options] Configuration options.
     * @param {MakeBucketPublicCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<MakeBucketPublicResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Make the bucket publicly readable.
     * //-
     * bucket.makePublic(function(err) {***REMOVED***);
     *
     * //-
     * // Make the bucket and its contents publicly readable.
     * //-
     * const opts = {
     *   includeFiles: true
     * ***REMOVED***;
     *
     * bucket.makePublic(opts, function(err, files) {
     *   // `err`:
     *   //    The first error to occur, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made public in the bucket.
     * ***REMOVED***);
     *
     * //-
     * // Make the bucket and its contents publicly readable, using force to
     * // suppress errors until all files have been processed.
     * //-
     * const opts = {
     *   includeFiles: true,
     *   force: true
     * ***REMOVED***;
     *
     * bucket.makePublic(opts, function(errors, files) {
     *   // `errors`:
     *   //    Array of errors if any occurred, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made public in the bucket.
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.makePublic(opts).then(function(data) {
     *   const files = data[0];
     * ***REMOVED***);
     */
    makePublic(optionsOrCallback, callback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {***REMOVED***;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const req = extend(true, { public: true ***REMOVED***, options);
        this.acl
            .add({
            entity: 'allUsers',
            role: 'READER',
      ***REMOVED***)
            .then(() => {
            return this.acl.default.add({
                entity: 'allUsers',
                role: 'READER',
          ***REMOVED***);
      ***REMOVED***)
            .then(() => {
            if (req.includeFiles) {
                return util_1.promisify(this.makeAllFilesPublicPrivate_).call(this, req);
          ***REMOVED***
            return [];
      ***REMOVED***)
            .then(files => callback(null, files), callback);
  ***REMOVED***
    /**
     * Get a reference to a Cloud Pub/Sub Notification.
     *
     * @param {string***REMOVED*** id ID of notification.
     * @returns {Notification***REMOVED***
     * @see Notification
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('my-bucket');
     * const notification = bucket.notification('1');
     */
    notification(id) {
        if (!id) {
            throw new Error('You must supply a notification ID.');
      ***REMOVED***
        return new notification_1.Notification(this, id);
  ***REMOVED***
    /**
     * Remove an already-existing retention policy from this bucket, if it is not
     * locked.
     *
     * @param {SetBucketMetadataCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<SetBucketMetadataResponse>***REMOVED***
     *
     * @example
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * bucket.removeRetentionPeriod(function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.removeRetentionPeriod().then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     */
    removeRetentionPeriod(callback) {
        this.setMetadata({
            retentionPolicy: null,
      ***REMOVED***, callback);
  ***REMOVED***
    /**
     * Makes request and applies userProject query parameter if necessary.
     *
     * @private
     *
     * @param {object***REMOVED*** reqOpts - The request options.
     * @param {function***REMOVED*** callback - The callback function.
     */
    request(reqOpts, callback) {
        if (this.userProject && (!reqOpts.qs || !reqOpts.qs.userProject)) {
            reqOpts.qs = extend(reqOpts.qs, { userProject: this.userProject ***REMOVED***);
      ***REMOVED***
        return super.request(reqOpts, callback);
  ***REMOVED***
    /**
     * @typedef {array***REMOVED*** SetLabelsResponse
     * @property {object***REMOVED*** 0 The bucket metadata.
     */
    /**
     * @callback SetLabelsCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** metadata The bucket metadata.
     */
    /**
     * @typedef {object***REMOVED*** SetLabelsOptions Configuration options for Bucket#setLabels().
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * Set labels on the bucket.
     *
     * This makes an underlying call to {@link Bucket#setMetadata***REMOVED***, which
     * is a PATCH request. This means an individual label can be overwritten, but
     * unmentioned labels will not be touched.
     *
     * @param {object<string, string>***REMOVED*** labels Labels to set on the bucket.
     * @param {object***REMOVED*** [options] Configuration options.
     * @param {SetLabelsCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<SetLabelsResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * const labels = {
     *   labelone: 'labelonevalue',
     *   labeltwo: 'labeltwovalue'
     * ***REMOVED***;
     *
     * bucket.setLabels(labels, function(err, metadata) {
     *   if (!err) {
     *     // Labels set successfully.
     * ***REMOVED***
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setLabels(labels).then(function(data) {
     *   const metadata = data[0];
     * ***REMOVED***);
     */
    setLabels(labels, optionsOrCallback, callback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {***REMOVED***;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        callback = callback || common_1.util.noop;
        this.setMetadata({ labels ***REMOVED***, options, callback);
  ***REMOVED***
    /**
     * Lock all objects contained in the bucket, based on their creation time. Any
     * attempt to overwrite or delete objects younger than the retention period
     * will result in a `PERMISSION_DENIED` error.
     *
     * An unlocked retention policy can be modified or removed from the bucket via
     * {@link File#removeRetentionPeriod***REMOVED*** and {@link File#setRetentionPeriod***REMOVED***. A
     * locked retention policy cannot be removed or shortened in duration for the
     * lifetime of the bucket. Attempting to remove or decrease period of a locked
     * retention policy will result in a `PERMISSION_DENIED` error. You can still
     * increase the policy.
     *
     * @param {****REMOVED*** duration In seconds, the minimum retention time for all objects
     *     contained in this bucket.
     * @param {SetBucketMetadataCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<SetBucketMetadataResponse>***REMOVED***
     *
     * @example
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * const DURATION_SECONDS = 15780000; // 6 months.
     *
     * //-
     * // Lock the objects in this bucket for 6 months.
     * //-
     * bucket.setRetentionPeriod(DURATION_SECONDS, function(err, apiResponse) {***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setRetentionPeriod(DURATION_SECONDS).then(function(data) {
     *   const apiResponse = data[0];
     * ***REMOVED***);
     */
    setRetentionPeriod(duration, callback) {
        this.setMetadata({
            retentionPolicy: {
                retentionPeriod: duration,
          ***REMOVED***,
      ***REMOVED***, callback);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** SetBucketStorageClassOptions
     * @param {string***REMOVED*** [userProject] - The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback SetBucketStorageClassCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     */
    /**
     * Set the default storage class for new files in this bucket.
     *
     * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes***REMOVED***
     *
     * @param {string***REMOVED*** storageClass The new storage class. (`standard`,
     *     `nearline`, `coldline`, or `durable_reduced_availability`).
     *     **Note:** The storage classes `multi_regional` and `regional`
     *     are now legacy and will be deprecated in the future.
     * @param {object***REMOVED*** [options] Configuration options.
     * @param {string***REMOVED*** [options.userProject] - The ID of the project which will be
     *     billed for the request.
     * @param {SetStorageClassCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.setStorageClass('nearline', function(err, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   // The storage class was updated successfully.
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setStorageClass('nearline').then(function() {***REMOVED***);
     */
    setStorageClass(storageClass, optionsOrCallback, callback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {***REMOVED***;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        // In case we get input like `storageClass`, convert to `storage_class`.
        storageClass = storageClass
            .replace(/-/g, '_')
            .replace(/([a-z])([A-Z])/g, (_, low, up) => {
            return low + '_' + up;
      ***REMOVED***)
            .toUpperCase();
        this.setMetadata({ storageClass ***REMOVED***, options, callback);
  ***REMOVED***
    /**
     * Set a user project to be billed for all requests made from this Bucket
     * object and any files referenced from this Bucket object.
     *
     * @param {string***REMOVED*** userProject The user project.
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.setUserProject('grape-spaceship-123');
     */
    setUserProject(userProject) {
        this.userProject = userProject;
        const methods = [
            'create',
            'delete',
            'exists',
            'get',
            'getMetadata',
            'setMetadata',
        ];
        methods.forEach(method => {
            const methodConfig = this.methods[method];
            if (typeof methodConfig === 'object') {
                if (typeof methodConfig.reqOpts === 'object') {
                    extend(methodConfig.reqOpts.qs, { userProject ***REMOVED***);
              ***REMOVED***
                else {
                    methodConfig.reqOpts = {
                        qs: { userProject ***REMOVED***,
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef {object***REMOVED*** UploadOptions Configuration options for Bucket#upload().
     * @param {string|File***REMOVED*** [options.destination] The place to save
     *     your file. If given a string, the file will be uploaded to the bucket
     *     using the string as a filename. When given a File object, your local
     * file will be uploaded to the File object's bucket and under the File
     * object's name. Lastly, when this argument is omitted, the file is uploaded
     * to your bucket using the name of the local file.
     * @param {string***REMOVED*** [options.encryptionKey] A custom encryption key. See
     *     [Customer-supplied Encryption
     * Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).
     * @param {boolean***REMOVED*** [options.gzip] Automatically gzip the file. This will set
     *     `options.metadata.contentEncoding` to `gzip`.
     * @param {string***REMOVED*** [options.kmsKeyName] The name of the Cloud KMS key that will
     *     be used to encrypt the object. Must be in the format:
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.
     * @param {object***REMOVED*** [options.metadata] See an
     *     [Objects: insert request
     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON).
     * @param {string***REMOVED*** [options.offset] The starting byte of the upload stream, for
     *     resuming an interrupted upload. Defaults to 0.
     * @param {string***REMOVED*** [options.predefinedAcl] Apply a predefined set of access
     *     controls to this object.
     *
     *     Acceptable values are:
     *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and
     *       `allAuthenticatedUsers` get `READER` access.
     *
     *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and
     *       project team owners get `OWNER` access.
     *
     *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project
     *       team owners get `READER` access.
     *
     *     - **`private`** - Object owner gets `OWNER` access.
     *
     *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project
     *       team members get access according to their roles.
     *
     *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`
     * get `READER` access.
     * @param {boolean***REMOVED*** [options.private] Make the uploaded file private. (Alias for
     *     `options.predefinedAcl = 'private'`)
     * @param {boolean***REMOVED*** [options.public] Make the uploaded file public. (Alias for
     *     `options.predefinedAcl = 'publicRead'`)
     * @param {boolean***REMOVED*** [options.resumable] Force a resumable upload. (default:
     *     true for files larger than 5 MB).
     * @param {string***REMOVED*** [options.uri] The URI for an already-created resumable
     *     upload. See {@link File#createResumableUpload***REMOVED***.
     * @param {string***REMOVED*** [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param {string|boolean***REMOVED*** [options.validation] Possible values: `"md5"`,
     *     `"crc32c"`, or `false`. By default, data integrity is validated with an
     *     MD5 checksum for maximum reliability. CRC32c will provide better
     *     performance with less reliability. You may also choose to skip
     * validation completely, however this is **not recommended**.
     */
    /**
     * @typedef {array***REMOVED*** UploadResponse
     * @property {object***REMOVED*** 0 The uploaded {@link File***REMOVED***.
     * @property {object***REMOVED*** 1 The full API response.
     */
    /**
     * @callback UploadCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {object***REMOVED*** file The uploaded {@link File***REMOVED***.
     * @param {object***REMOVED*** apiResponse The full API response.
     */
    /**
     * Upload a file to the bucket. This is a convenience method that wraps
     * {@link File#createWriteStream***REMOVED***.
     *
     * You can specify whether or not an upload is resumable by setting
     * `options.resumable`. *Resumable uploads are enabled by default if your
     * input file is larger than 5 MB.*
     *
     * For faster crc32c computation, you must manually install
     * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):
     *
     *     $ npm install --save fast-crc32c
     *
     * @see [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads***REMOVED***
     * @see [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert***REMOVED***
     *
     * @param {string***REMOVED*** pathString The fully qualified path to the file you
     *     wish to upload to your bucket.
     * @param {UploadOptions***REMOVED*** [options] Configuration options.
     * @param {UploadCallback***REMOVED*** [callback] Callback function.
     * @returns {Promise<UploadResponse>***REMOVED***
     *
     * @example
     * const {Storage***REMOVED*** = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Upload a file from a local path.
     * //-
     * bucket.upload('/local/path/image.png', function(err, file, apiResponse) {
     *   // Your bucket now contains:
     *   // - "image.png" (with the contents of `/local/path/image.png')
     *
     *   // `file` is an instance of a File object that refers to your new file.
     * ***REMOVED***);
     *
     *
     * //-
     * // It's not always that easy. You will likely want to specify the filename
     * // used when your new file lands in your bucket.
     * //
     * // You may also want to set metadata or customize other options.
     * //-
     * const options = {
     *   destination: 'new-image.png',
     *   resumable: true,
     *   validation: 'crc32c',
     *   metadata: {
     *     metadata: {
     *       event: 'Fall trip to the zoo'
     *   ***REMOVED***
     * ***REMOVED***
     * ***REMOVED***;
     *
     * bucket.upload('local-image.png', options, function(err, file) {
     *   // Your bucket now contains:
     *   // - "new-image.png" (with the contents of `local-image.png')
     *
     *   // `file` is an instance of a File object that refers to your new file.
     * ***REMOVED***);
     *
     * //-
     * // You can also have a file gzip'd on the fly.
     * //-
     * bucket.upload('index.html', { gzip: true ***REMOVED***, function(err, file) {
     *   // Your bucket now contains:
     *   // - "index.html" (automatically compressed with gzip)
     *
     *   // Downloading the file with `file.download` will automatically decode
     * the
     *   // file.
     * ***REMOVED***);
     *
     * //-
     * // You may also re-use a File object, {File***REMOVED***, that references
     * // the file you wish to create or overwrite.
     * //-
     * const options = {
     *   destination: bucket.file('existing-file.png'),
     *   resumable: false
     * ***REMOVED***;
     *
     * bucket.upload('local-img.png', options, function(err, newFile) {
     *   // Your bucket now contains:
     *   // - "existing-file.png" (with the contents of `local-img.png')
     *
     *   // Note:
     *   // The `newFile` parameter is equal to `file`.
     * ***REMOVED***);
     *
     * //-
     * // To use
     * // <a
     * href="https://cloud.google.com/storage/docs/encryption#customer-supplied">
     * // Customer-supplied Encryption Keys</a>, provide the `encryptionKey`
     * option.
     * //-
     * const crypto = require('crypto');
     * const encryptionKey = crypto.randomBytes(32);
     *
     * bucket.upload('img.png', {
     *   encryptionKey: encryptionKey
     * ***REMOVED***, function(err, newFile) {
     *   // `img.png` was uploaded with your custom encryption key.
     *
     *   // `newFile` is already configured to use the encryption key when making
     *   // operations on the remote object.
     *
     *   // However, to use your encryption key later, you must create a `File`
     *   // instance with the `key` supplied:
     *   const file = bucket.file('img.png', {
     *     encryptionKey: encryptionKey
     * ***REMOVED***);
     *
     *   // Or with `file#setEncryptionKey`:
     *   const file = bucket.file('img.png');
     *   file.setEncryptionKey(encryptionKey);
     * ***REMOVED***);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.upload('local-image.png').then(function(data) {
     *   const file = data[0];
     * ***REMOVED***);
     *
     * To upload a file from a URL, use {@link File#createWriteStream***REMOVED***.
     *
     * @example <caption>include:samples/files.js</caption>
     * region_tag:storage_upload_file
     * Another example:
     *
     * @example <caption>include:samples/encryption.js</caption>
     * region_tag:storage_upload_encrypted_file
     * Example of uploading an encrypted file:
     */
    upload(pathString, optionsOrCallback, callback) {
        // tslint:disable-next-line:no-any
        if (global['GCLOUD_SANDBOX_ENV']) {
            return;
      ***REMOVED***
        let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {***REMOVED***;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        options = Object.assign({
            metadata: {***REMOVED***,
      ***REMOVED***, options);
        let newFile;
        if (options.destination instanceof file_1.File) {
            newFile = options.destination;
      ***REMOVED***
        else if (options.destination != null &&
            typeof options.destination === 'string') {
            // Use the string as the name of the file.
            newFile = this.file(options.destination, {
                encryptionKey: options.encryptionKey,
                kmsKeyName: options.kmsKeyName,
          ***REMOVED***);
      ***REMOVED***
        else {
            // Resort to using the name of the incoming file.
            const destination = path.basename(pathString);
            newFile = this.file(destination, {
                encryptionKey: options.encryptionKey,
                kmsKeyName: options.kmsKeyName,
          ***REMOVED***);
      ***REMOVED***
        const contentType = mime.contentType(path.basename(pathString));
        if (contentType && !options.metadata.contentType) {
            options.metadata.contentType = contentType;
      ***REMOVED***
        if (options.resumable != null && typeof options.resumable === 'boolean') {
            upload();
      ***REMOVED***
        else {
            // Determine if the upload should be resumable if it's over the threshold.
            fs.stat(pathString, (err, fd) => {
                if (err) {
                    callback(err);
                    return;
              ***REMOVED***
                options.resumable = fd.size > RESUMABLE_THRESHOLD;
                upload();
          ***REMOVED***);
      ***REMOVED***
        function upload() {
            fs.createReadStream(pathString)
                .on('error', callback)
                .pipe(newFile.createWriteStream(options))
                .on('error', callback)
                .on('finish', () => {
                callback(null, newFile, newFile.metadata);
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    /**
     * @private
     *
     * @typedef {object***REMOVED*** MakeAllFilesPublicPrivateOptions
     * @property {boolean***REMOVED*** [force] Suppress errors until all files have been
     *     processed.
     * @property {boolean***REMOVED*** [private] Make files private.
     * @property {boolean***REMOVED*** [public] Make files public.
     * @property {string***REMOVED*** [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @private
     *
     * @callback SetBucketMetadataCallback
     * @param {?Error***REMOVED*** err Request error, if any.
     * @param {File[]***REMOVED*** files Files that were updated.
     */
    /**
     * @typedef {array***REMOVED*** MakeAllFilesPublicPrivateResponse
     * @property {File[]***REMOVED*** 0 List of files affected.
     */
    /**
     * Iterate over all of a bucket's files, calling `file.makePublic()` (public)
     * or `file.makePrivate()` (private) on each.
     *
     * Operations are performed in parallel, up to 10 at once. The first error
     * breaks the loop, and will execute the provided callback with it. Specify
     * `{ force: true ***REMOVED***` to suppress the errors.
     *
     * @private
     *
     * @param {MakeAllFilesPublicPrivateOptions***REMOVED*** [options] Configuration options.
     * @param {MakeAllFilesPublicPrivateCallback***REMOVED*** callback Callback function.
     *
     * @return {Promise<MakeAllFilesPublicPrivateResponse>***REMOVED***
     */
    makeAllFilesPublicPrivate_(optionsOrCallback, callback) {
        const MAX_PARALLEL_LIMIT = 10;
        const errors = [];
        const updatedFiles = [];
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {***REMOVED***;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const processFile = async (file) => {
            try {
                await (options.public ? file.makePublic() : file.makePrivate(options));
                updatedFiles.push(file);
          ***REMOVED***
            catch (e) {
                if (!options.force) {
                    throw e;
              ***REMOVED***
                errors.push(e);
          ***REMOVED***
      ***REMOVED***
        this.getFiles(options)
            .then(([files]) => {
            const limit = p_limit_1.default(MAX_PARALLEL_LIMIT);
            const promises = files.map(file => {
                return limit(() => processFile(file));
          ***REMOVED***);
            return Promise.all(promises);
      ***REMOVED***)
            .then(() => callback(errors.length > 0 ? errors : null, updatedFiles), err => callback(err, updatedFiles));
  ***REMOVED***
    getId() {
        return this.id;
  ***REMOVED***
***REMOVED***
exports.Bucket = Bucket;
/*! Developer Documentation
 *
 * These methods can be auto-paginated.
 */
paginator_1.paginator.extend(Bucket, 'getFiles');
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
promisify_1.promisifyAll(Bucket, {
    exclude: ['request', 'file', 'notification'],
***REMOVED***);
//# sourceMappingURL=bucket.js.map