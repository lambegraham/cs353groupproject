"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const convert_1 = require("./convert");
const field_value_1 = require("./field-value");
const field_value_2 = require("./field-value");
const geo_point_1 = require("./geo-point");
const index_1 = require("./index");
const path_1 = require("./path");
const timestamp_1 = require("./timestamp");
const util_1 = require("./util");
const validate_1 = require("./validate");
/**
 * The maximum depth of a Firestore object.
 *
 * @private
 */
const MAX_DEPTH = 20;
/**
 * Serializer that is used to convert between JavaScript types and their
 * Firestore Protobuf representation.
 *
 * @private
 */
class Serializer {
    constructor(firestore) {
        // Instead of storing the `firestore` object, we store just a reference to
        // its `.doc()` method. This avoid a circular reference, which breaks
        // JSON.stringify().
        this.createReference = path => firestore.doc(path);
        // tslint:disable-next-line deprecation
        if (firestore._settings.timestampsInSnapshots === undefined) {
            this.timestampsInSnapshots = true;
      ***REMOVED***
        else {
            // tslint:disable-next-line deprecation
            this.timestampsInSnapshots = firestore._settings.timestampsInSnapshots;
      ***REMOVED***
  ***REMOVED***
    /**
     * Encodes a JavaScript object into the Firestore 'Fields' representation.
     *
     * @private
     * @param obj The object to encode.
     * @returns The Firestore 'Fields' representation
     */
    encodeFields(obj) {
        const fields = {***REMOVED***;
        for (const prop of Object.keys(obj)) {
            const val = this.encodeValue(obj[prop]);
            if (val) {
                fields[prop] = val;
          ***REMOVED***
      ***REMOVED***
        return fields;
  ***REMOVED***
    /**
     * Encodes a JavaScript value into the Firestore 'Value' representation.
     *
     * @private
     * @param val The object to encode
     * @returns The Firestore Proto or null if we are deleting a field.
     */
    encodeValue(val) {
        if (val instanceof field_value_1.FieldTransform) {
            return null;
      ***REMOVED***
        if (typeof val === 'string') {
            return {
                stringValue: val,
          ***REMOVED***
      ***REMOVED***
        if (typeof val === 'boolean') {
            return {
                booleanValue: val,
          ***REMOVED***
      ***REMOVED***
        if (typeof val === 'number') {
            if (Number.isSafeInteger(val)) {
                return {
                    integerValue: val,
              ***REMOVED***
          ***REMOVED***
            else {
                return {
                    doubleValue: val,
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (val instanceof Date) {
            const timestamp = timestamp_1.Timestamp.fromDate(val);
            return {
                timestampValue: {
                    seconds: timestamp.seconds,
                    nanos: timestamp.nanoseconds,
              ***REMOVED***,
          ***REMOVED***
      ***REMOVED***
        if (val === null) {
            return {
                nullValue: 'NULL_VALUE',
          ***REMOVED***
      ***REMOVED***
        if (val instanceof Buffer || val instanceof Uint8Array) {
            return {
                bytesValue: val,
          ***REMOVED***
      ***REMOVED***
        if (util_1.isObject(val)) {
            const toProto = val['toProto'];
            if (typeof toProto === 'function') {
                return toProto.bind(val)();
          ***REMOVED***
      ***REMOVED***
        if (val instanceof Array) {
            const array = {
                arrayValue: {***REMOVED***,
          ***REMOVED***
            if (val.length > 0) {
                array.arrayValue.values = [];
                for (let i = 0; i < val.length; ++i) {
                    const enc = this.encodeValue(val[i]);
                    if (enc) {
                        array.arrayValue.values.push(enc);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            return array;
      ***REMOVED***
        if (typeof val === 'object' && isPlainObject(val)) {
            const map = {
                mapValue: {***REMOVED***,
          ***REMOVED***
            // If we encounter an empty object, we always need to send it to make sure
            // the server creates a map entry.
            if (!util_1.isEmpty(val)) {
                map.mapValue.fields = this.encodeFields(val);
                if (util_1.isEmpty(map.mapValue.fields)) {
                    return null;
              ***REMOVED***
          ***REMOVED***
            return map;
      ***REMOVED***
        throw new Error(`Cannot encode value: ${val***REMOVED***`);
  ***REMOVED***
    /**
     * Decodes a single Firestore 'Value' Protobuf.
     *
     * @private
     * @param proto A Firestore 'Value' Protobuf.
     * @returns The converted JS type.
     */
    decodeValue(proto) {
        const valueType = convert_1.detectValueType(proto);
        switch (valueType) {
            case 'stringValue': {
                return proto.stringValue;
          ***REMOVED***
            case 'booleanValue': {
                return proto.booleanValue;
          ***REMOVED***
            case 'integerValue': {
                return Number(proto.integerValue);
          ***REMOVED***
            case 'doubleValue': {
                return Number(proto.doubleValue);
          ***REMOVED***
            case 'timestampValue': {
                const timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);
                return this.timestampsInSnapshots ? timestamp : timestamp.toDate();
          ***REMOVED***
            case 'referenceValue': {
                const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);
                return this.createReference(resourcePath.relativeName);
          ***REMOVED***
            case 'arrayValue': {
                const array = [];
                if (Array.isArray(proto.arrayValue.values)) {
                    for (const value of proto.arrayValue.values) {
                        array.push(this.decodeValue(value));
                  ***REMOVED***
              ***REMOVED***
                return array;
          ***REMOVED***
            case 'nullValue': {
                return null;
          ***REMOVED***
            case 'mapValue': {
                const obj = {***REMOVED***;
                const fields = proto.mapValue.fields;
                if (fields) {
                    for (const prop of Object.keys(fields)) {
                        obj[prop] = this.decodeValue(fields[prop]);
                  ***REMOVED***
              ***REMOVED***
                return obj;
          ***REMOVED***
            case 'geoPointValue': {
                return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);
          ***REMOVED***
            case 'bytesValue': {
                return proto.bytesValue;
          ***REMOVED***
            default: {
                throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
***REMOVED***
exports.Serializer = Serializer;
/**
 * Verifies that 'obj' is a plain JavaScript object that can be encoded as a
 * 'Map' in Firestore.
 *
 * @private
 * @param input The argument to verify.
 * @returns 'true' if the input can be a treated as a plain object.
 */
function isPlainObject(input) {
    return (util_1.isObject(input) &&
        (Object.getPrototypeOf(input) === Object.prototype ||
            Object.getPrototypeOf(input) === null));
***REMOVED***
exports.isPlainObject = isPlainObject;
/**
 * Validates a JavaScript value for usage as a Firestore value.
 *
 * @private
 * @param arg The argument name or argument index (for varargs methods).
 * @param value JavaScript value to validate.
 * @param desc A description of the expected type.
 * @param path The field path to validate.
 * @param options Validation options
 * @param level The current depth of the traversal. This is used to decide
 * whether deletes are allowed in conjunction with `allowDeletes: root`.
 * @param inArray Whether we are inside an array.
 * @throws when the object is invalid.
 */
function validateUserInput(arg, value, desc, options, path, level, inArray) {
    if (path && path.size > MAX_DEPTH) {
        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** Input object is deeper than ${MAX_DEPTH***REMOVED*** levels or contains a cycle.`);
  ***REMOVED***
    options = options || {***REMOVED***;
    level = level || 0;
    inArray = inArray || false;
    const fieldPathMessage = path ? ` (found in field ${path***REMOVED***)` : '';
    if (Array.isArray(value)) {
        for (let i = 0; i < value.length; ++i) {
            validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, 
            /* inArray= */ true);
      ***REMOVED***
  ***REMOVED***
    else if (isPlainObject(value)) {
        for (const prop of Object.keys(value)) {
            validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);
      ***REMOVED***
  ***REMOVED***
    else if (value === undefined) {
        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** Cannot use "undefined" as a Firestore value${fieldPathMessage***REMOVED***.`);
  ***REMOVED***
    else if (value instanceof field_value_2.DeleteTransform) {
        if (inArray) {
            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** ${value.methodName***REMOVED***() cannot be used inside of an array${fieldPathMessage***REMOVED***.`);
      ***REMOVED***
        else if ((options.allowDeletes === 'root' && level !== 0) ||
            options.allowDeletes === 'none') {
            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** ${value.methodName***REMOVED***() must appear at the top-level and can only be used in update() or set() with {merge:true***REMOVED***${fieldPathMessage***REMOVED***.`);
      ***REMOVED***
  ***REMOVED***
    else if (value instanceof field_value_1.FieldTransform) {
        if (inArray) {
            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** ${value.methodName***REMOVED***() cannot be used inside of an array${fieldPathMessage***REMOVED***.`);
      ***REMOVED***
        else if (!options.allowTransforms) {
            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** ${value.methodName***REMOVED***() can only be used in set(), create() or update()${fieldPathMessage***REMOVED***.`);
      ***REMOVED***
  ***REMOVED***
    else if (value instanceof path_1.FieldPath) {
        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)***REMOVED*** Cannot use object of type "FieldPath" as a Firestore value${fieldPathMessage***REMOVED***.`);
  ***REMOVED***
    else if (value instanceof index_1.DocumentReference) {
        // Ok.
  ***REMOVED***
    else if (value instanceof geo_point_1.GeoPoint) {
        // Ok.
  ***REMOVED***
    else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {
        // Ok.
  ***REMOVED***
    else if (value instanceof Buffer || value instanceof Uint8Array) {
        // Ok.
  ***REMOVED***
    else if (value === null) {
        // Ok.
  ***REMOVED***
    else if (typeof value === 'object') {
        throw new Error(validate_1.customObjectMessage(arg, value, path));
  ***REMOVED***
***REMOVED***
exports.validateUserInput = validateUserInput;
//# sourceMappingURL=serializer.js.map