"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof global !== "undefined" && global
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>***REMOVED***
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object***REMOVED***
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({***REMOVED***) : /* istanbul ignore next */ {***REMOVED***; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean***REMOVED***
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {****REMOVED*** value Value to test
 * @returns {boolean***REMOVED*** `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
***REMOVED***;

/**
 * Tests if the specified value is a string.
 * @param {****REMOVED*** value Value to test
 * @returns {boolean***REMOVED*** `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
***REMOVED***;

/**
 * Tests if the specified value is a non-null object.
 * @param {****REMOVED*** value Value to test
 * @returns {boolean***REMOVED*** `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
***REMOVED***;

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet***REMOVED***.
 * @function
 * @param {Object***REMOVED*** obj Plain object or message instance
 * @param {string***REMOVED*** prop Property name
 * @returns {boolean***REMOVED*** `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object***REMOVED*** obj Plain object or message instance
 * @param {string***REMOVED*** prop Property name
 * @returns {boolean***REMOVED*** `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
***REMOVED***;

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>***REMOVED***
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
  ***REMOVED*** catch (e) {
        /* istanbul ignore next */
        return null;
  ***REMOVED***
***REMOVED***)();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]***REMOVED*** [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer***REMOVED*** Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
***REMOVED***;

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>***REMOVED***
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number***REMOVED*** low Low bits
 * @property {number***REMOVED*** high High bits
 * @property {boolean***REMOVED*** unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>***REMOVED***
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp***REMOVED***
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp***REMOVED***
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp***REMOVED***
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8***REMOVED***|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number***REMOVED*** value Value to convert
 * @returns {string***REMOVED*** Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
***REMOVED***;

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string***REMOVED*** hash Hash
 * @param {boolean***REMOVED*** [unsigned=false] Whether unsigned or not
 * @returns {Long|number***REMOVED*** Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
***REMOVED***;

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>***REMOVED*** dst Destination object
 * @param {Object.<string,*>***REMOVED*** src Source object
 * @param {boolean***REMOVED*** [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>***REMOVED*** Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
***REMOVED***

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string***REMOVED*** str String to convert
 * @returns {string***REMOVED*** Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
***REMOVED***;

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string***REMOVED*** name Error name
 * @returns {Constructor<Error>***REMOVED*** Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; ***REMOVED*** ***REMOVED***);

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" ***REMOVED***);

        if (properties)
            merge(this, properties);
  ***REMOVED***

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; ***REMOVED*** ***REMOVED***);

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
  ***REMOVED***

    return CustomError;
***REMOVED***

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string***REMOVED*** message Error message
 * @param {Object.<string,*>***REMOVED*** [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * ***REMOVED*** catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * ***REMOVED***
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>***REMOVED***
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter***REMOVED***.
 * @typedef OneOfGetter
 * @type {function***REMOVED***
 * @returns {string|undefined***REMOVED*** Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]***REMOVED*** fieldNames Field names
 * @returns {OneOfGetter***REMOVED*** Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {***REMOVED***;
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined***REMOVED*** Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
  ***REMOVED***
***REMOVED***;

/**
 * A OneOf setter as returned by {@link util.oneOfSetter***REMOVED***.
 * @typedef OneOfSetter
 * @type {function***REMOVED***
 * @param {string|undefined***REMOVED*** value Field name
 * @returns {undefined***REMOVED***
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]***REMOVED*** fieldNames Field names
 * @returns {OneOfSetter***REMOVED*** Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string***REMOVED*** name Field name
     * @returns {undefined***REMOVED***
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
  ***REMOVED***
***REMOVED***;

/**
 * Default conversion options used for {@link Message#toJSON***REMOVED*** implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions***REMOVED***
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
***REMOVED***;

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
  ***REMOVED***
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
      ***REMOVED***
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
      ***REMOVED***
***REMOVED***;
