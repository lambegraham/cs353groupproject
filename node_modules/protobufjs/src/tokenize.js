"use strict";
module.exports = tokenize;

var delimRe        = /[\s{***REMOVED***=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
***REMOVED***;

/**
 * Unescapes a string.
 * @param {string***REMOVED*** str String to unescape
 * @returns {string***REMOVED*** Unescaped string
 * @property {Object.<string,string>***REMOVED*** map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
      ***REMOVED***
  ***REMOVED***);
***REMOVED***

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function***REMOVED***
 * @returns {string|null***REMOVED*** Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function***REMOVED***
 * @returns {string|null***REMOVED*** Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function***REMOVED***
 * @param {string***REMOVED*** token Token
 * @returns {undefined***REMOVED***
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function***REMOVED***
 * @param {string***REMOVED*** expected Expected token
 * @param {boolean***REMOVED*** [optional=false] If optional
 * @returns {boolean***REMOVED*** Whether the token matched
 * @throws {Error***REMOVED*** If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function***REMOVED***
 * @param {number***REMOVED*** [line] Line number
 * @returns {string|null***REMOVED*** Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize***REMOVED***.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext***REMOVED*** next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek***REMOVED*** peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush***REMOVED*** push Pushes a token back to the stack
 * @property {TokenizerHandleSkip***REMOVED*** skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt***REMOVED*** cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number***REMOVED*** line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string***REMOVED*** source Source contents
 * @param {boolean***REMOVED*** alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle***REMOVED*** Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string***REMOVED*** subject Subject
     * @returns {Error***REMOVED*** Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
  ***REMOVED***

    /**
     * Reads a string till its end.
     * @returns {string***REMOVED*** String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
  ***REMOVED***

    /**
     * Gets the character at `pos` within the source.
     * @param {number***REMOVED*** pos Position
     * @returns {string***REMOVED*** Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
  ***REMOVED***

    /**
     * Sets the current comment text.
     * @param {number***REMOVED*** start Start offset
     * @param {number***REMOVED*** end End offset
     * @returns {undefined***REMOVED***
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
      ***REMOVED*** else {
            lookback = 3;  // "///" or "/**"
      ***REMOVED***
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
          ***REMOVED***
      ***REMOVED*** while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
  ***REMOVED***

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2***REMOVED***/.test(lineText);
        return isComment;
  ***REMOVED***

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
      ***REMOVED***
        return endOffset;
  ***REMOVED***

    /**
     * Obtains the next token.
     * @returns {string|null***REMOVED*** Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
          ***REMOVED***

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
              ***REMOVED***
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                          ***REMOVED***
                      ***REMOVED***
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1);
                      ***REMOVED***
                        ++line;
                        repeat = true;
                  ***REMOVED*** else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                              ***REMOVED***
                                offset++;
                          ***REMOVED*** while (isDoubleSlashCommentLine(offset));
                      ***REMOVED*** else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                      ***REMOVED***
                        if (isDoc) {
                            setComment(start, offset);
                      ***REMOVED***
                        line++;
                        repeat = true;
                  ***REMOVED***
              ***REMOVED*** else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                      ***REMOVED***
                        if (++offset === length) {
                            throw illegal("comment");
                      ***REMOVED***
                        prev = curr;
                        curr = charAt(offset);
                  ***REMOVED*** while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2);
                  ***REMOVED***
                    repeat = true;
              ***REMOVED*** else {
                    return "/";
              ***REMOVED***
          ***REMOVED***
      ***REMOVED*** while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
  ***REMOVED***

    /**
     * Pushes a token back to the stack.
     * @param {string***REMOVED*** token Token
     * @returns {undefined***REMOVED***
     * @inner
     */
    function push(token) {
        stack.push(token);
  ***REMOVED***

    /**
     * Peeks for the next token.
     * @returns {string|null***REMOVED*** Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
      ***REMOVED***
        return stack[0];
  ***REMOVED***

    /**
     * Skips a token.
     * @param {string***REMOVED*** expected Expected token
     * @param {boolean***REMOVED*** [optional=false] Whether the token is optional
     * @returns {boolean***REMOVED*** `true` when skipped, `false` if not
     * @throws {Error***REMOVED*** When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
      ***REMOVED***
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
  ***REMOVED***

    /**
     * Gets a comment.
     * @param {number***REMOVED*** [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null***REMOVED*** Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentText;
          ***REMOVED***
      ***REMOVED*** else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
          ***REMOVED***
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentText;
          ***REMOVED***
      ***REMOVED***
        return ret;
  ***REMOVED***

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
  ***REMOVED***, "line", {
        get: function() { return line; ***REMOVED***
  ***REMOVED***);
    /* eslint-enable callback-return */
***REMOVED***
