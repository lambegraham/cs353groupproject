"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod***REMOVED***.
 *
 * Differs from {@link RPCImplCallback***REMOVED*** in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function***REMOVED***
 * @param {Error|null***REMOVED*** error Error, if any
 * @param {TRes***REMOVED*** [response] Response message
 * @returns {undefined***REMOVED***
 */

/**
 * A service method part of a {@link rpc.Service***REMOVED*** as created by {@link Service.create***REMOVED***.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function***REMOVED***
 * @param {TReq|Properties<TReq>***REMOVED*** request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>***REMOVED*** [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>***REMOVED*** Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create***REMOVED***.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl***REMOVED*** rpcImpl RPC implementation
 * @param {boolean***REMOVED*** [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean***REMOVED*** [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null***REMOVED***
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean***REMOVED***
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean***REMOVED***
     */
    this.responseDelimited = Boolean(responseDelimited);
***REMOVED***

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl***REMOVED***.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>***REMOVED*** method Reflected or static method
 * @param {Constructor<TReq>***REMOVED*** requestCtor Request constructor
 * @param {Constructor<TRes>***REMOVED*** responseCtor Response constructor
 * @param {TReq|Properties<TReq>***REMOVED*** request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>***REMOVED*** callback Service callback
 * @returns {undefined***REMOVED***
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); ***REMOVED***, 0);
        return undefined;
  ***REMOVED***

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
              ***REMOVED***

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
              ***REMOVED***

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                  ***REMOVED*** catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                  ***REMOVED***
              ***REMOVED***

                self.emit("data", response, method);
                return callback(null, response);
          ***REMOVED***
        );
  ***REMOVED*** catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); ***REMOVED***, 0);
        return undefined;
  ***REMOVED***
***REMOVED***;

/**
 * Ends this service and emits the `end` event.
 * @param {boolean***REMOVED*** [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service***REMOVED*** `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
  ***REMOVED***
    return this;
***REMOVED***;
