/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
/**
 * @typedef {object***REMOVED*** PrivateData
 * @property {EventTarget***REMOVED*** eventTarget The event target.
 * @property {{type:string***REMOVED******REMOVED*** event The original event object.
 * @property {number***REMOVED*** eventPhase The current event phase.
 * @property {EventTarget|null***REMOVED*** currentTarget The current event target.
 * @property {boolean***REMOVED*** canceled The flag to prevent default.
 * @property {boolean***REMOVED*** stopped The flag to stop propagation.
 * @property {boolean***REMOVED*** immediateStopped The flag to stop propagation immediately.
 * @property {Function|null***REMOVED*** passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number***REMOVED*** timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>***REMOVED***
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>***REMOVED***
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event***REMOVED*** event The event object to get private data.
 * @returns {PrivateData***REMOVED*** The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
    );
    return retv
***REMOVED***

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData***REMOVED*** private data.
 */
function setCancelFlag(data) {
    if (data.passiveListener != null) {
        if (
            typeof console !== "undefined" &&
            typeof console.error === "function"
        ) {
            console.error(
                "Unable to preventDefault inside passive event listener invocation.",
                data.passiveListener
            );
      ***REMOVED***
        return
  ***REMOVED***
    if (!data.event.cancelable) {
        return
  ***REMOVED***

    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
  ***REMOVED***
***REMOVED***

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget***REMOVED*** eventTarget The event target of this dispatching.
 * @param {Event|{type:string***REMOVED******REMOVED*** event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
  ***REMOVED***);

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true ***REMOVED***);

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
      ***REMOVED***
  ***REMOVED***
***REMOVED***

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string***REMOVED***
     */
    get type() {
        return pd(this).event.type
  ***REMOVED***,

    /**
     * The target of this event.
     * @type {EventTarget***REMOVED***
     */
    get target() {
        return pd(this).eventTarget
  ***REMOVED***,

    /**
     * The target of this event.
     * @type {EventTarget***REMOVED***
     */
    get currentTarget() {
        return pd(this).currentTarget
  ***REMOVED***,

    /**
     * @returns {EventTarget[]***REMOVED*** The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
      ***REMOVED***
        return [currentTarget]
  ***REMOVED***,

    /**
     * Constant of NONE.
     * @type {number***REMOVED***
     */
    get NONE() {
        return 0
  ***REMOVED***,

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number***REMOVED***
     */
    get CAPTURING_PHASE() {
        return 1
  ***REMOVED***,

    /**
     * Constant of AT_TARGET.
     * @type {number***REMOVED***
     */
    get AT_TARGET() {
        return 2
  ***REMOVED***,

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number***REMOVED***
     */
    get BUBBLING_PHASE() {
        return 3
  ***REMOVED***,

    /**
     * The target of this event.
     * @type {number***REMOVED***
     */
    get eventPhase() {
        return pd(this).eventPhase
  ***REMOVED***,

    /**
     * Stop event bubbling.
     * @returns {void***REMOVED***
     */
    stopPropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
      ***REMOVED***
  ***REMOVED***,

    /**
     * Stop event bubbling.
     * @returns {void***REMOVED***
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
      ***REMOVED***
  ***REMOVED***,

    /**
     * The flag to be bubbling.
     * @type {boolean***REMOVED***
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
  ***REMOVED***,

    /**
     * The flag to be cancelable.
     * @type {boolean***REMOVED***
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
  ***REMOVED***,

    /**
     * Cancel this event.
     * @returns {void***REMOVED***
     */
    preventDefault() {
        setCancelFlag(pd(this));
  ***REMOVED***,

    /**
     * The flag to indicate cancellation state.
     * @type {boolean***REMOVED***
     */
    get defaultPrevented() {
        return pd(this).canceled
  ***REMOVED***,

    /**
     * The flag to be composed.
     * @type {boolean***REMOVED***
     */
    get composed() {
        return Boolean(pd(this).event.composed)
  ***REMOVED***,

    /**
     * The unix time of this event.
     * @type {number***REMOVED***
     */
    get timeStamp() {
        return pd(this).timeStamp
  ***REMOVED***,

    /**
     * The target of this event.
     * @type {EventTarget***REMOVED***
     * @deprecated
     */
    get srcElement() {
        return pd(this).eventTarget
  ***REMOVED***,

    /**
     * The flag to stop event bubbling.
     * @type {boolean***REMOVED***
     * @deprecated
     */
    get cancelBubble() {
        return pd(this).stopped
  ***REMOVED***,
    set cancelBubble(value) {
        if (!value) {
            return
      ***REMOVED***
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
            data.event.cancelBubble = true;
      ***REMOVED***
  ***REMOVED***,

    /**
     * The flag to indicate cancellation state.
     * @type {boolean***REMOVED***
     * @deprecated
     */
    get returnValue() {
        return !pd(this).canceled
  ***REMOVED***,
    set returnValue(value) {
        if (!value) {
            setCancelFlag(pd(this));
      ***REMOVED***
  ***REMOVED***,

    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param {string***REMOVED*** type The event type.
     * @param {boolean***REMOVED*** [bubbles=false] The flag to be possible to bubble up.
     * @param {boolean***REMOVED*** [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent() {
        // Do nothing.
  ***REMOVED***,
***REMOVED***;

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true,
***REMOVED***);

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
***REMOVED***

/**
 * Get the property descriptor to redirect a given property.
 * @param {string***REMOVED*** key Property name to define property descriptor.
 * @returns {PropertyDescriptor***REMOVED*** The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
      ***REMOVED***,
        set(value) {
            pd(this).event[key] = value;
      ***REMOVED***,
        configurable: true,
        enumerable: true,
  ***REMOVED***
***REMOVED***

/**
 * Get the property descriptor to call a given method property.
 * @param {string***REMOVED*** key Property name to define property descriptor.
 * @returns {PropertyDescriptor***REMOVED*** The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
      ***REMOVED***,
        configurable: true,
        enumerable: true,
  ***REMOVED***
***REMOVED***

/**
 * Define new wrapper class.
 * @param {Function***REMOVED*** BaseEvent The base wrapper class.
 * @param {Object***REMOVED*** proto The prototype of the original event.
 * @returns {Function***REMOVED*** The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
  ***REMOVED***

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
  ***REMOVED***

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true ***REMOVED***,
  ***REMOVED***);

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc
                    ? defineCallDescriptor(key)
                    : defineRedirectDescriptor(key)
            );
      ***REMOVED***
  ***REMOVED***

    return CustomEvent
***REMOVED***

/**
 * Get the wrapper class of a given prototype.
 * @param {Object***REMOVED*** proto The prototype of the original event to get its wrapper.
 * @returns {Function***REMOVED*** The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
  ***REMOVED***

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
  ***REMOVED***
    return wrapper
***REMOVED***

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget***REMOVED*** eventTarget The event target of this dispatching.
 * @param {Object***REMOVED*** event The event to wrap.
 * @returns {Event***REMOVED*** The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
***REMOVED***

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event***REMOVED*** event The event to get.
 * @returns {boolean***REMOVED*** The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).immediateStopped
***REMOVED***

/**
 * Set the current event phase of a given event.
 * @param {Event***REMOVED*** event The event to set current target.
 * @param {number***REMOVED*** eventPhase New event phase.
 * @returns {void***REMOVED***
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
***REMOVED***

/**
 * Set the current target of a given event.
 * @param {Event***REMOVED*** event The event to set current target.
 * @param {EventTarget|null***REMOVED*** currentTarget New current target.
 * @returns {void***REMOVED***
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
***REMOVED***

/**
 * Set a passive listener of a given event.
 * @param {Event***REMOVED*** event The event to set current target.
 * @param {Function|null***REMOVED*** passiveListener New passive listener.
 * @returns {void***REMOVED***
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
***REMOVED***

/**
 * @typedef {object***REMOVED*** ListenerNode
 * @property {Function***REMOVED*** listener
 * @property {1|2|3***REMOVED*** listenerType
 * @property {boolean***REMOVED*** passive
 * @property {boolean***REMOVED*** once
 * @property {ListenerNode|null***REMOVED*** next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>***REMOVED***
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any***REMOVED*** x The value to check.
 * @returns {boolean***REMOVED*** `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
***REMOVED***

/**
 * Get listeners.
 * @param {EventTarget***REMOVED*** eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>***REMOVED*** The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError(
            "'this' is expected an EventTarget object, but got another value."
        )
  ***REMOVED***
    return listeners
***REMOVED***

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string***REMOVED*** eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor***REMOVED*** The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
              ***REMOVED***
                node = node.next;
          ***REMOVED***
            return null
      ***REMOVED***,

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
          ***REMOVED***
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                  ***REMOVED*** else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                  ***REMOVED*** else {
                        listeners.delete(eventName);
                  ***REMOVED***
              ***REMOVED*** else {
                    prev = node;
              ***REMOVED***

                node = node.next;
          ***REMOVED***

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
              ***REMOVED***
                if (prev === null) {
                    listeners.set(eventName, newNode);
              ***REMOVED*** else {
                    prev.next = newNode;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***,
        configurable: true,
        enumerable: true,
  ***REMOVED***
***REMOVED***

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object***REMOVED*** eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string***REMOVED*** eventName The event name to define.
 * @returns {void***REMOVED***
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(
        eventTargetPrototype,
        `on${eventName***REMOVED***`,
        defineEventAttributeDescriptor(eventName)
    );
***REMOVED***

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]***REMOVED*** eventNames Event names for event attributes.
 * @returns {EventTarget***REMOVED*** The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
  ***REMOVED***

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
            value: CustomEventTarget,
            configurable: true,
            writable: true,
      ***REMOVED***,
  ***REMOVED***);

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  ***REMOVED***

    return CustomEventTarget
***REMOVED***

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {***REMOVED***
 *     class B extends EventTarget("message") {***REMOVED***
 *     class C extends EventTarget("message", "error") {***REMOVED***
 *     class D extends EventTarget(["message", "error"]) {***REMOVED***
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
  ***REMOVED***
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
  ***REMOVED***
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
      ***REMOVED***
        return defineCustomEventTarget(types)
  ***REMOVED***
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
***REMOVED***

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string***REMOVED*** eventName The event name to add.
     * @param {Function***REMOVED*** listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean***REMOVED******REMOVED*** [options] The options for this listener.
     * @returns {void***REMOVED***
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return
      ***REMOVED***
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
      ***REMOVED***

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
      ***REMOVED***

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return
      ***REMOVED***

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                // Should ignore duplication.
                return
          ***REMOVED***
            prev = node;
            node = node.next;
      ***REMOVED***

        // Add it.
        prev.next = newNode;
  ***REMOVED***,

    /**
     * Remove a given listener from this event target.
     * @param {string***REMOVED*** eventName The event name to remove.
     * @param {Function***REMOVED*** listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean***REMOVED******REMOVED*** [options] The options for this listener.
     * @returns {void***REMOVED***
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return
      ***REMOVED***

        const listeners = getListeners(this);
        const capture = isObject(options)
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                if (prev !== null) {
                    prev.next = node.next;
              ***REMOVED*** else if (node.next !== null) {
                    listeners.set(eventName, node.next);
              ***REMOVED*** else {
                    listeners.delete(eventName);
              ***REMOVED***
                return
          ***REMOVED***

            prev = node;
            node = node.next;
      ***REMOVED***
  ***REMOVED***,

    /**
     * Dispatch a given event.
     * @param {Event|{type:string***REMOVED******REMOVED*** event The event to dispatch.
     * @returns {boolean***REMOVED*** `false` if canceled.
     */
    dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
            throw new TypeError('"event.type" should be a string.')
      ***REMOVED***

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
      ***REMOVED***

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
              ***REMOVED*** else if (node.next !== null) {
                    listeners.set(eventName, node.next);
              ***REMOVED*** else {
                    listeners.delete(eventName);
              ***REMOVED***
          ***REMOVED*** else {
                prev = node;
          ***REMOVED***

            // Call this listener
            setPassiveListener(
                wrappedEvent,
                node.passive ? node.listener : null
            );
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
              ***REMOVED*** catch (err) {
                    if (
                        typeof console !== "undefined" &&
                        typeof console.error === "function"
                    ) {
                        console.error(err);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED*** else if (
                node.listenerType !== ATTRIBUTE &&
                typeof node.listener.handleEvent === "function"
            ) {
                node.listener.handleEvent(wrappedEvent);
          ***REMOVED***

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
          ***REMOVED***

            node = node.next;
      ***REMOVED***
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
  ***REMOVED***,
***REMOVED***;

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true,
***REMOVED***);

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
) {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
***REMOVED***

export default EventTarget;
export { defineEventAttribute, EventTarget ***REMOVED***;
//# sourceMappingURL=event-target-shim.mjs.map
