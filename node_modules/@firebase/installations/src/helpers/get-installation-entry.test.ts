/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { AssertionError, expect ***REMOVED*** from 'chai';
import { SinonFakeTimers, SinonStub, stub, useFakeTimers ***REMOVED*** from 'sinon';
import * as createInstallationModule from '../api/create-installation';
import { AppConfig ***REMOVED*** from '../interfaces/app-config';
import {
  InProgressInstallationEntry,
  RegisteredInstallationEntry,
  RequestStatus,
  UnregisteredInstallationEntry
***REMOVED*** from '../interfaces/installation-entry';
import { getFakeAppConfig ***REMOVED*** from '../testing/get-fake-app';
import '../testing/setup';
import { ERROR_FACTORY, ErrorCode ***REMOVED*** from '../util/errors';
import { sleep ***REMOVED*** from '../util/sleep';
import * as generateFidModule from './generate-fid';
import { getInstallationEntry ***REMOVED*** from './get-installation-entry';
import { get, set ***REMOVED*** from './idb-manager';

const FID = 'cry-of-the-black-birds';

describe('getInstallationEntry', () => {
  let clock: SinonFakeTimers;
  let appConfig: AppConfig;
  let createInstallationSpy: SinonStub<
    [AppConfig, InProgressInstallationEntry],
    Promise<RegisteredInstallationEntry>
  >;

  beforeEach(() => {
    clock = useFakeTimers();
    appConfig = getFakeAppConfig();
    createInstallationSpy = stub(
      createInstallationModule,
      'createInstallation'
    ).callsFake(
      async (_, installationEntry): Promise<RegisteredInstallationEntry> => {
        await sleep(100); // Request would take some time
        const registeredInstallationEntry: RegisteredInstallationEntry = {
          // Returns new FID if client FID is invalid.
          fid: installationEntry.fid || FID,
          registrationStatus: RequestStatus.COMPLETED,
          refreshToken: 'refreshToken',
          authToken: {
            requestStatus: RequestStatus.COMPLETED,
            creationTime: Date.now(),
            token: 'token',
            expiresIn: 1_000_000_000
        ***REMOVED***
      ***REMOVED***
        return registeredInstallationEntry;
    ***REMOVED***
    );
***REMOVED***);

  it('saves the InstallationEntry in the database before returning it', async () => {
    const oldDbEntry = await get(appConfig);
    expect(oldDbEntry).to.be.undefined;

    const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

    const newDbEntry = await get(appConfig);
    expect(newDbEntry).to.deep.equal(installationEntry);
***REMOVED***);

  it('saves the InstallationEntry in the database if app is offline', async () => {
    stub(navigator, 'onLine').value(false);

    const oldDbEntry = await get(appConfig);
    expect(oldDbEntry).to.be.undefined;

    const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

    const newDbEntry = await get(appConfig);
    expect(newDbEntry).to.deep.equal(installationEntry);
***REMOVED***);

  it('saves the InstallationEntry in the database when registration completes', async () => {
    const {
      installationEntry,
      registrationPromise
  ***REMOVED*** = await getInstallationEntry(appConfig);
    expect(installationEntry.registrationStatus).to.equal(
      RequestStatus.IN_PROGRESS
    );
    expect(registrationPromise).to.be.an.instanceOf(Promise);

    const oldDbEntry = await get(appConfig);
    expect(oldDbEntry).to.deep.equal(installationEntry);

    clock.next(); // Finish registration request.
    await expect(registrationPromise).to.be.fulfilled;

    const newDbEntry = await get(appConfig);
    expect(newDbEntry!.registrationStatus).to.equal(RequestStatus.COMPLETED);
***REMOVED***);

  it('saves the InstallationEntry in the database when registration fails', async () => {
    createInstallationSpy.callsFake(async () => {
      await sleep(100); // Request would take some time
      throw ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {
        requestName: 'Create Installation',
        serverCode: 500,
        serverStatus: 'INTERNAL',
        serverMessage: 'Internal server error.'
    ***REMOVED***);
  ***REMOVED***);

    const {
      installationEntry,
      registrationPromise
  ***REMOVED*** = await getInstallationEntry(appConfig);
    expect(installationEntry.registrationStatus).to.equal(
      RequestStatus.IN_PROGRESS
    );
    expect(registrationPromise).to.be.an.instanceOf(Promise);

    const oldDbEntry = await get(appConfig);
    expect(oldDbEntry).to.deep.equal(installationEntry);

    clock.next(); // Finish registration request.
    await expect(registrationPromise).to.be.rejected;

    const newDbEntry = await get(appConfig);
    expect(newDbEntry!.registrationStatus).to.equal(RequestStatus.NOT_STARTED);
***REMOVED***);

  it('removes the InstallationEntry from the database when registration fails with 409', async () => {
    createInstallationSpy.callsFake(async () => {
      await sleep(100); // Request would take some time
      throw ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {
        requestName: 'Create Installation',
        serverCode: 409,
        serverStatus: 'INVALID_ARGUMENT',
        serverMessage: 'FID can not be used.'
    ***REMOVED***);
  ***REMOVED***);

    const {
      installationEntry,
      registrationPromise
  ***REMOVED*** = await getInstallationEntry(appConfig);
    expect(installationEntry.registrationStatus).to.equal(
      RequestStatus.IN_PROGRESS
    );

    const oldDbEntry = await get(appConfig);
    expect(oldDbEntry).to.deep.equal(installationEntry);

    clock.next(); // Finish registration request.
    await expect(registrationPromise).to.be.rejected;

    const newDbEntry = await get(appConfig);
    expect(newDbEntry).to.be.undefined;
***REMOVED***);

  it('returns the same FID on subsequent calls', async () => {
    const { installationEntry: entry1 ***REMOVED*** = await getInstallationEntry(appConfig);
    const { installationEntry: entry2 ***REMOVED*** = await getInstallationEntry(appConfig);
    expect(entry1.fid).to.equal(entry2.fid);
***REMOVED***);

  describe('when there is no InstallationEntry in database', () => {
    let generateInstallationEntrySpy: SinonStub<[], string>;

    beforeEach(() => {
      generateInstallationEntrySpy = stub(
        generateFidModule,
        'generateFid'
      ).returns(FID);
  ***REMOVED***);

    it('returns a new pending InstallationEntry and triggers createInstallation', async () => {
      const {
        installationEntry,
        registrationPromise
    ***REMOVED*** = await getInstallationEntry(appConfig);

      if (installationEntry.registrationStatus !== RequestStatus.IN_PROGRESS) {
        throw new AssertionError('InstallationEntry is not IN_PROGRESS.');
    ***REMOVED***

      expect(registrationPromise).to.be.an.instanceOf(Promise);
      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.IN_PROGRESS,

        // https://github.com/chaijs/chai/issues/644
        registrationTime: installationEntry.registrationTime
    ***REMOVED***);
      expect(generateInstallationEntrySpy).to.be.called;
      expect(createInstallationSpy).to.be.called;
  ***REMOVED***);

    it('returns a new unregistered InstallationEntry if app is offline', async () => {
      stub(navigator, 'onLine').value(false);

      const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.NOT_STARTED
    ***REMOVED***);
      expect(generateInstallationEntrySpy).to.be.called;
      expect(createInstallationSpy).not.to.be.called;
  ***REMOVED***);

    it('does not trigger createInstallation REST call on subsequent calls', async () => {
      await getInstallationEntry(appConfig);
      await getInstallationEntry(appConfig);

      expect(createInstallationSpy).to.be.calledOnce;
  ***REMOVED***);

    it('returns a registrationPromise on subsequent calls before initial promise resolves', async () => {
      const { registrationPromise: promise1 ***REMOVED*** = await getInstallationEntry(
        appConfig
      );
      const { registrationPromise: promise2 ***REMOVED*** = await getInstallationEntry(
        appConfig
      );

      expect(createInstallationSpy).to.be.calledOnce;
      expect(promise1).to.be.an.instanceOf(Promise);
      expect(promise2).to.be.an.instanceOf(Promise);
  ***REMOVED***);

    it('does not return a registrationPromise on subsequent calls after initial promise resolves', async () => {
      const { registrationPromise: promise1 ***REMOVED*** = await getInstallationEntry(
        appConfig
      );
      expect(promise1).to.be.an.instanceOf(Promise);

      clock.next(); // Finish registration request.
      await expect(promise1).to.be.fulfilled;

      const { registrationPromise: promise2 ***REMOVED*** = await getInstallationEntry(
        appConfig
      );
      expect(promise2).to.be.undefined;

      expect(createInstallationSpy).to.be.calledOnce;
  ***REMOVED***);

    it('waits for the FID from the server if FID generation fails', async () => {
      clock.restore();
      // Needed to allow the createInstallation request to complete.
      clock = useFakeTimers({ shouldAdvanceTime: true ***REMOVED***);

      // FID generation fails.
      generateInstallationEntrySpy.returns(generateFidModule.INVALID_FID);

      const getInstallationEntryPromise = getInstallationEntry(appConfig);

      const {
        installationEntry,
        registrationPromise
    ***REMOVED*** = await getInstallationEntryPromise;

      expect(installationEntry.fid).to.equal(FID);
      expect(registrationPromise).to.be.undefined;
  ***REMOVED***);
***REMOVED***);

  describe('when there is an unregistered InstallationEntry in the database', () => {
    beforeEach(async () => {
      const unregisteredInstallationEntry: UnregisteredInstallationEntry = {
        fid: FID,
        registrationStatus: RequestStatus.NOT_STARTED
    ***REMOVED***
      await set(appConfig, unregisteredInstallationEntry);
  ***REMOVED***);

    it('returns a pending InstallationEntry and triggers createInstallation', async () => {
      const {
        installationEntry,
        registrationPromise
    ***REMOVED*** = await getInstallationEntry(appConfig);

      if (installationEntry.registrationStatus !== RequestStatus.IN_PROGRESS) {
        throw new AssertionError('InstallationEntry is not IN_PROGRESS.');
    ***REMOVED***

      expect(registrationPromise).to.be.an.instanceOf(Promise);
      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.IN_PROGRESS,
        // https://github.com/chaijs/chai/issues/644
        registrationTime: installationEntry.registrationTime
    ***REMOVED***);
      expect(createInstallationSpy).to.be.calledOnce;
  ***REMOVED***);

    it('returns the same InstallationEntry if the app is offline', async () => {
      stub(navigator, 'onLine').value(false);

      const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.NOT_STARTED
    ***REMOVED***);
      expect(createInstallationSpy).not.to.be.called;
  ***REMOVED***);
***REMOVED***);

  describe('when there is a pending InstallationEntry in the database', () => {
    beforeEach(async () => {
      const inProgressInstallationEntry: InProgressInstallationEntry = {
        fid: FID,
        registrationStatus: RequestStatus.IN_PROGRESS,
        registrationTime: 1_000_000
    ***REMOVED***
      await set(appConfig, inProgressInstallationEntry);
  ***REMOVED***);

    it("returns the same InstallationEntry if the request hasn't timed out", async () => {
      stub(Date, 'now').returns(1_001_000); // One second later

      const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.IN_PROGRESS,
        registrationTime: 1_000_000
    ***REMOVED***);
      expect(createInstallationSpy).not.to.be.called;
  ***REMOVED***);

    it('returns a new pending InstallationEntry and triggers createInstallation if the request timed out', async () => {
      stub(Date, 'now').returns(1_015_000); // Fifteen seconds later

      const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.IN_PROGRESS,
        registrationTime: 1_015_000
    ***REMOVED***);
      expect(createInstallationSpy).to.be.calledOnce;
  ***REMOVED***);

    it('returns a new unregistered InstallationEntry if the request timed out and the app is offline', async () => {
      stub(navigator, 'onLine').value(false);
      stub(Date, 'now').returns(1_015_000); // Fifteen seconds later

      const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.NOT_STARTED
    ***REMOVED***);
      expect(createInstallationSpy).not.to.be.called;
  ***REMOVED***);
***REMOVED***);

  describe('when there is a registered InstallationEntry in the database', () => {
    beforeEach(async () => {
      const registeredInstallationEntry: RegisteredInstallationEntry = {
        fid: FID,
        registrationStatus: RequestStatus.COMPLETED,
        refreshToken: 'refreshToken',
        authToken: { requestStatus: RequestStatus.NOT_STARTED ***REMOVED***
    ***REMOVED***
      await set(appConfig, registeredInstallationEntry);
  ***REMOVED***);

    it('returns the InstallationEntry from the database', async () => {
      const { installationEntry ***REMOVED*** = await getInstallationEntry(appConfig);

      expect(installationEntry).to.deep.equal({
        fid: FID,
        registrationStatus: RequestStatus.COMPLETED,
        refreshToken: 'refreshToken',
        authToken: { requestStatus: RequestStatus.NOT_STARTED ***REMOVED***
    ***REMOVED***);
      expect(createInstallationSpy).not.to.be.called;
  ***REMOVED***);
***REMOVED***);
***REMOVED***);
