import {
  objectOrFunction,
  isFunction
***REMOVED*** from './utils';

import {
  asap
***REMOVED*** from './asap';

import originalThen from './then';
import originalResolve from './promise/resolve';

export const PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {***REMOVED***

const PENDING   = void 0;
const FULFILLED = 1;
const REJECTED  = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
***REMOVED***

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
***REMOVED***

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
***REMOVED*** catch(e) {
    return e;
***REMOVED***
***REMOVED***

function handleForeignThenable(promise, thenable, then) {
   asap(promise => {
    let sealed = false;
    let error = tryThen(then, thenable, value => {
      if (sealed) { return; ***REMOVED***
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
    ***REMOVED*** else {
        fulfill(promise, value);
    ***REMOVED***
  ***REMOVED***, reason => {
      if (sealed) { return; ***REMOVED***
      sealed = true;

      reject(promise, reason);
  ***REMOVED***, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
  ***REMOVED***
***REMOVED***, promise);
***REMOVED***

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
***REMOVED*** else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
***REMOVED*** else {
    subscribe(thenable, undefined, value  => resolve(promise, value),
                                   reason => reject(promise, reason))
***REMOVED***
***REMOVED***

function handleMaybeThenable(promise, maybeThenable, then) {
  if (maybeThenable.constructor === promise.constructor &&
      then === originalThen &&
      maybeThenable.constructor.resolve === originalResolve) {
    handleOwnThenable(promise, maybeThenable);
***REMOVED*** else {
    if (then === undefined) {
      fulfill(promise, maybeThenable);
  ***REMOVED*** else if (isFunction(then)) {
      handleForeignThenable(promise, maybeThenable, then);
  ***REMOVED*** else {
      fulfill(promise, maybeThenable);
  ***REMOVED***
***REMOVED***
***REMOVED***

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
***REMOVED*** else if (objectOrFunction(value)) {
    let then;
    try {
      then = value.then;
  ***REMOVED*** catch (error) {
      reject(promise, error);
      return;
  ***REMOVED***
    handleMaybeThenable(promise, value, then);
***REMOVED*** else {
    fulfill(promise, value);
***REMOVED***
***REMOVED***

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
***REMOVED***

  publish(promise);
***REMOVED***

function fulfill(promise, value) {
  if (promise._state !== PENDING) { return; ***REMOVED***

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
***REMOVED***
***REMOVED***

function reject(promise, reason) {
  if (promise._state !== PENDING) { return; ***REMOVED***
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
***REMOVED***

function subscribe(parent, child, onFulfillment, onRejection) {
  let { _subscribers ***REMOVED*** = parent;
  let { length ***REMOVED*** = _subscribers;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED]  = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
***REMOVED***
***REMOVED***

function publish(promise) {
  let subscribers = promise._subscribers;
  let settled = promise._state;

  if (subscribers.length === 0) { return; ***REMOVED***

  let child, callback, detail = promise._result;

  for (let i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
  ***REMOVED*** else {
      callback(detail);
  ***REMOVED***
***REMOVED***

  promise._subscribers.length = 0;
***REMOVED***

function invokeCallback(settled, promise, callback, detail) {
  let hasCallback = isFunction(callback),
      value, error, succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
  ***REMOVED*** catch (e) {
      succeeded = false;
      error = e;
  ***REMOVED***

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
  ***REMOVED***
***REMOVED*** else {
    value = detail;
***REMOVED***

  if (promise._state !== PENDING) {
    // noop
***REMOVED*** else if (hasCallback && succeeded) {
    resolve(promise, value);
***REMOVED*** else if (succeeded === false) {
    reject(promise, error);
***REMOVED*** else if (settled === FULFILLED) {
    fulfill(promise, value);
***REMOVED*** else if (settled === REJECTED) {
    reject(promise, value);
***REMOVED***
***REMOVED***

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value){
      resolve(promise, value);
  ***REMOVED***, function rejectPromise(reason) {
      reject(promise, reason);
  ***REMOVED***);
***REMOVED*** catch(e) {
    reject(promise, e);
***REMOVED***
***REMOVED***

let id = 0;
function nextId() {
  return id++;
***REMOVED***

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
***REMOVED***

export {
  nextId,
  makePromise,
  noop,
  resolve,
  reject,
  fulfill,
  subscribe,
  publish,
  publishRejection,
  initializePromise,
  invokeCallback,
  FULFILLED,
  REJECTED,
  PENDING,
  handleMaybeThenable
***REMOVED***;
